<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二叉树的子结构</title>
    <link href="/2023/12/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <url>/2023/12/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的子结构"><a href="#二叉树的子结构" class="headerlink" title="二叉树的子结构"></a>二叉树的子结构</h3><h6 id="输入两颗二叉树A和B，判断B是不是A的子结构。二叉树节点的定义如下："><a href="#输入两颗二叉树A和B，判断B是不是A的子结构。二叉树节点的定义如下：" class="headerlink" title="输入两颗二叉树A和B，判断B是不是A的子结构。二叉树节点的定义如下："></a>输入两颗二叉树A和B，判断B是不是A的子结构。二叉树节点的定义如下：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryTreeNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    BinaryTreeNode *left;<br>    BinaryTreeNode *right;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><ul><li><p>B只有一个节点</p><p>此时只需要遍历A中所有节点并进行对比。</p></li><li><p>B有多个节点</p><p>同样需要遍历A中所有节点</p><ul><li>先找到与B的根节点相等的节点，然后再对比左右子树。</li></ul></li><li><p>判别条件</p><ul><li><p>当对比到B的空节点</p><ul><li><p>若还没对比到A的空节点，表明B已没有节点再进行比较，判定为真。</p></li><li><p>若对比到了A的空节点，说明A和B结构一样，都没有多余需要对比的节点，判定为真。</p></li></ul></li><li><p>当对比到了A的空节点</p><ul><li><p>若还没对比到B的空节点，说明A没有节点再来和B的节点比较，B节点更多，则B不是A的子结构。</p></li><li><p>若对比到了B的空节点，说明两者结构一样，判定为真。</p></li></ul></li></ul></li></ul></blockquote><ul><li>双递归形式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 遍历A，找到与B根节点匹配的节点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasSubTree</span><span class="hljs-params">(BinaryTreeNode *rootA, BinaryTreeNode *rootB)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (rootA &amp;&amp; rootB)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (rootA-&gt;m_data == rootB-&gt;m_data)<br>        &#123;<br>            result = <span class="hljs-built_in">isSubTree</span>(rootA, rootB);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!result)<br>        &#123;<br>            <span class="hljs-built_in">hasSubTree</span>(rootA-&gt;left, rootB);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!result)<br>        &#123;<br>            <span class="hljs-built_in">hasSubTree</span>(rootA-&gt;right, rootB);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判断以pA为根子树是否包含以pB为根的子树</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubTree</span><span class="hljs-params">(BinaryTreeNode *pA, BinaryTreeNode *pB)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pB == <span class="hljs-literal">nullptr</span> &amp;&amp; pA != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pB == <span class="hljs-literal">nullptr</span> &amp;&amp; pA == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pA == <span class="hljs-literal">nullptr</span> &amp;&amp; pB != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pA-&gt;m_data != pB-&gt;m_data)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubTree</span>(pA-&gt;left, pB-&gt;left) &amp;&amp; <span class="hljs-built_in">isSubTree</span>(pA-&gt;right, pB-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用队列辅助</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubTreeBy</span><span class="hljs-params">(BinaryTreeNode *root, BinaryTreeNode *subRoot)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> || subRoot == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    vector&lt;BinaryTreeNode *&gt; nodes;<br>    queue&lt;BinaryTreeNode *&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        BinaryTreeNode *p = q.<span class="hljs-built_in">front</span>();<br>        nodes.<span class="hljs-built_in">push_back</span>(p);<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (p-&gt;left)<br>        &#123;<br>            q.<span class="hljs-built_in">push</span>(p-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p-&gt;right)<br>        &#123;<br>            q.<span class="hljs-built_in">push</span>(p-&gt;right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> node : nodes)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;m_data == subRoot-&gt;m_data)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubTree</span>(node, subRoot);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="/2023/12/03/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/12/03/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><h6 id="输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。链表节点定义如下："><a href="#输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。链表节点定义如下：" class="headerlink" title="输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。链表节点定义如下："></a>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。链表节点定义如下：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    ListNode *next;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>对于两个有序链表，合并后还是需要有序</p><ul><li><p>两个指针遍历两个有序链表</p><ul><li>把其中更小的节点取下放入新的有序链表，然后当前指针后移，另一条链表的遍历指针不动。</li></ul></li></ul></blockquote><ul><li>递归形式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">mergeRecuisive</span><span class="hljs-params">(ListNode *head1, ListNode *head2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head1 == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head2;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head2 == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head1;<br>    &#125;<br><br>    ListNode *pMerge = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (head1-&gt;m_data &lt; head2-&gt;m_data)<br>    &#123;<br>        pMerge = head1;<br>        <span class="hljs-comment">// head1后移，head2不动</span><br>        pMerge-&gt;next = <span class="hljs-built_in">mergeRecuisive</span>(head1-&gt;next, head2);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        pMerge = head2;<br>        pMerge = <span class="hljs-built_in">mergeRecuisive</span>(head1, head2-&gt;next);<br>    &#125;<br>    <span class="hljs-keyword">return</span> pMerge;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>循环形式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">loopMerge</span><span class="hljs-params">(ListNode *head1, ListNode *head2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head1 == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head2;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head2 == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head1;<br>    &#125;<br><br>    ListNode *pMergeHead = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 采用尾插法</span><br>    ListNode *pMergeTail = <span class="hljs-literal">nullptr</span>;<br>    ListNode *p1 = head1;<br>    ListNode *p2 = head2;<br>    <span class="hljs-keyword">if</span> (head1-&gt;m_data &lt;= head2-&gt;m_data)<br>    &#123;<br>        pMergeHead = head1;<br>        pMergeTail = head1;<br>        p1 = p1-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        pMergeHead = head2;<br>        pMergeTail = head2;<br>        p2 = p2-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (p1 &amp;&amp; p2)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (p1-&gt;m_data &lt;= p2-&gt;m_data)<br>        &#123;<br>            pMergeTail-&gt;next = p1;<br>            p1 = p1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pMergeTail-&gt;next = p2;<br>            p2 = p2-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 其中一条链表遍历完，另一条链表还有剩，接到尾节点之后即可</span><br>    <span class="hljs-keyword">if</span> (p1)<br>    &#123;<br>        pMergeTail-&gt;next = p1;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p2)<br>    &#123;<br>        pMergeTail-&gt;next = p2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表</title>
    <link href="/2023/12/02/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/12/02/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h6 id="定义一个函数，输入一个链表的投机点，反转该链表并输出反转后链表的头节点。节点定义如下："><a href="#定义一个函数，输入一个链表的投机点，反转该链表并输出反转后链表的头节点。节点定义如下：" class="headerlink" title="定义一个函数，输入一个链表的投机点，反转该链表并输出反转后链表的头节点。节点定义如下："></a>定义一个函数，输入一个链表的投机点，反转该链表并输出反转后链表的头节点。节点定义如下：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    ListNode *next;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>反转链表就是将每个节点的指针反转</p><ul><li><p>cur指针遍历链表每个节点，并修改每个节点的指针域。</p></li><li><p>每个修改的指针域需要指向该节点的前驱节点，因此前驱节点需要记下来。</p></li><li><p>当前节点指针域修改后，就无法找到其后继节点，因此在修改前需要将后继节点记下来。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    ListNode *reverseHead = <span class="hljs-literal">nullptr</span>;<br>    ListNode *pre = <span class="hljs-literal">nullptr</span>;<br>    ListNode *cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        ListNode *pNext = cur-&gt;next;<br>        <span class="hljs-comment">// 后继节点为空，当前节点就是尾节点，即反转后的头节点</span><br>        <span class="hljs-keyword">if</span> (pNext == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            reverseHead = cur;<br>        &#125;<br><br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = pNext;<br>    &#125;<br>    <span class="hljs-keyword">return</span> reverseHead;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表中环的入口节点</title>
    <link href="/2023/11/30/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/"/>
    <url>/2023/11/30/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h3><h6 id="如果一个链表中包含环，如何找出环的入口节点？节点定义如下："><a href="#如果一个链表中包含环，如何找出环的入口节点？节点定义如下：" class="headerlink" title="如果一个链表中包含环，如何找出环的入口节点？节点定义如下："></a>如果一个链表中包含环，如何找出环的入口节点？节点定义如下：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    ListNode *next;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><ul><li><p>首先确定链表是否包含环</p><p>类似于追击问题，如果一个指针走一步，一个指针走两步</p><p>如果两指针相遇，则一定包含环；否则，没有环</p></li><li><p>找出环的入口</p><p>如果一个环含有n个节点，则快指针先走n步（把环多出的节点消耗）；然后两指针同步移动，相遇时指向的就是环的入口。</p></li><li><p>确定一个环含有几个节点</p><p>在确定链表包含环时，两指针相遇的位置一定在环中。</p><p>此时一个指针不动，另一个指针向前移动并计数，当回到起点就可以确定环中节点数目。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 找出环中相遇的节点</span><br><span class="hljs-function">ListNode *<span class="hljs-title">meetNode</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    ListNode *slow = head-&gt;next;<br>    ListNode *fast = head-&gt;next;<br><br>    <span class="hljs-keyword">while</span> (slow &amp;&amp; fast)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (slow == fast)<br>        &#123;<br>            <span class="hljs-keyword">return</span> slow;<br>        &#125;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next;<br>        <span class="hljs-keyword">if</span> (fast)<br>        &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function">ListNode *<span class="hljs-title">entryNode</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode *meetingNode = <span class="hljs-built_in">meetNode</span>(head);<br>    <span class="hljs-keyword">if</span> (meetingNode == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>    ListNode *p = meetingNode;<br>    <span class="hljs-keyword">while</span> (p-&gt;next != meetingNode)<br>    &#123;<br>        p = p-&gt;next;<br>        count++;<br>    &#125;<br><br>    ListNode *fast = head;<br>    ListNode *slow = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>    &#123;<br>        fast = fast-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (slow != fast)<br>    &#123;<br>        fast = fast-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表中倒数第k个节点</title>
    <link href="/2023/11/28/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2023/11/28/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><h6 id="输入一个链表，输出该链表中倒数第k个节点。从1开始计数，即链表最后一个节点是倒数第一个节点。节点定义如下"><a href="#输入一个链表，输出该链表中倒数第k个节点。从1开始计数，即链表最后一个节点是倒数第一个节点。节点定义如下" class="headerlink" title="输入一个链表，输出该链表中倒数第k个节点。从1开始计数，即链表最后一个节点是倒数第一个节点。节点定义如下"></a>输入一个链表，输出该链表中倒数第k个节点。从1开始计数，即链表最后一个节点是倒数第一个节点。节点定义如下</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    ListNode *next;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>思路一：</p><ul><li><p>先从头到尾遍历一次链表，并对节点个数进行计数n。</p></li><li><p>倒数第k个，就是n-k+1。</p></li></ul><p>该方法需要遍历两次链表。</p><p>思路二：</p><ul><li><p>使用一前一后两个指针。</p></li><li><p>前指针先走k-1步（因为倒数第k个节点和最后一个节点间隔为k-1）。</p></li><li><p>然后两指针同步移动，当前指针走到尾节点时，后指针指向的就是倒数第k个节点。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">findKToTail</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || k &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    ListNode *fast = head;<br>    ListNode *slow = head;<br><br>    <span class="hljs-type">int</span> step = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (step &lt;= k - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (fast-&gt;next)<br>        &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// k超出链表范围</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (fast-&gt;next) <span class="hljs-comment">// 当fast-&gt;next为空时，fast就指向了尾节点</span><br>    &#123;<br>        fast = fast-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调整数组顺序</title>
    <link href="/2023/11/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F/"/>
    <url>/2023/11/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="调整数组顺序使得奇数在前偶数在后"><a href="#调整数组顺序使得奇数在前偶数在后" class="headerlink" title="调整数组顺序使得奇数在前偶数在后"></a>调整数组顺序使得奇数在前偶数在后</h3><h6 id="输入一个整数数组，实现一个函数使得数组中的所有奇数位于前半部分，所有偶数位于后半部分。"><a href="#输入一个整数数组，实现一个函数使得数组中的所有奇数位于前半部分，所有偶数位于后半部分。" class="headerlink" title="输入一个整数数组，实现一个函数使得数组中的所有奇数位于前半部分，所有偶数位于后半部分。"></a>输入一个整数数组，实现一个函数使得数组中的所有奇数位于前半部分，所有偶数位于后半部分。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>一前一后双指针</p><ul><li><p>前指针找到一个偶数</p></li><li><p>后指针找到一个奇数</p></li><li><p>交换两者位置</p></li><li><p>直到两指针相遇</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeEven</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> length, <span class="hljs-type">bool</span> (*isEven)(<span class="hljs-type">int</span>))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> end = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (begin &lt; end)<br>    &#123;<br>        <span class="hljs-comment">// 如果是偶数，则继续向前寻找，直到找到一个奇数</span><br>        <span class="hljs-keyword">while</span> (begin &lt; end &amp;&amp; <span class="hljs-built_in">isEven</span>(arr[end]) == <span class="hljs-literal">true</span>)<br>        &#123;<br>            end--;<br>        &#125;<br>        <span class="hljs-comment">// 如果是奇数，则继续向后寻找，直到找到一个偶数</span><br>        <span class="hljs-keyword">while</span> (begin &lt; end &amp;&amp; <span class="hljs-built_in">isEven</span>(arr[begin]) == <span class="hljs-literal">false</span>)<br>        &#123;<br>            begin++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (begin &lt; end)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(arr[begin], arr[end]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表中重复元素</title>
    <link href="/2023/11/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2023/11/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="删除链表中的重复元素"><a href="#删除链表中的重复元素" class="headerlink" title="删除链表中的重复元素"></a>删除链表中的重复元素</h3><h6 id="在一个排序的链表中，删除重复节点，重复的节点一个都不保留。"><a href="#在一个排序的链表中，删除重复节点，重复的节点一个都不保留。" class="headerlink" title="在一个排序的链表中，删除重复节点，重复的节点一个都不保留。"></a>在一个排序的链表中，删除重复节点，重复的节点一个都不保留。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>从头开始遍历链表</p><ul><li><p>如果当前节点与后一节点出现重复现象，那么需要进行删除操作。</p><ul><li>用临时指针从开始重复的节点开始遍历，边遍历边删除，直到出现第一个不重复的节点。</li></ul></li><li><p>为了不断开链表的连接，需要保留当前节点的前一节点指针。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteDuplicate</span><span class="hljs-params">(ListNode *&amp;head)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode *pre = <span class="hljs-literal">nullptr</span>;<br>    ListNode *cur = head;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        ListNode *pNext = cur-&gt;next;<br>        <span class="hljs-comment">// 出现重复现象</span><br>        <span class="hljs-keyword">if</span> (pNext &amp;&amp; pNext-&gt;m_data == cur-&gt;m_data)<br>        &#123;<br>            <span class="hljs-type">int</span> data = cur-&gt;m_data;<br>            <span class="hljs-comment">// q遍历每一个重复的节点并删除</span><br>            ListNode *q = cur;<br>            <span class="hljs-keyword">while</span> (q &amp;&amp; q-&gt;m_data == data)<br>            &#123;<br>                pNext = q-&gt;next;<br>                <span class="hljs-keyword">delete</span> q;<br>                q = <span class="hljs-literal">nullptr</span>;<br>                q = pNext;<br>            &#125;<br>            <span class="hljs-comment">// 退出循环时，q指向和前面节点不重复的第一个节点</span><br>            <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                head = q;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                pre-&gt;next = q;<br>            &#125;<br>            cur = q;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pre = cur;<br>            cur = pNext;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表指定节点</title>
    <link href="/2023/11/24/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9/"/>
    <url>/2023/11/24/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="删除链表中的指定节点"><a href="#删除链表中的指定节点" class="headerlink" title="删除链表中的指定节点"></a>删除链表中的指定节点</h3><h6 id="给定一个单链表的头指针和一个节点指针，定义一个函数在O-1-时间内删除该节点。节点定义如下："><a href="#给定一个单链表的头指针和一个节点指针，定义一个函数在O-1-时间内删除该节点。节点定义如下：" class="headerlink" title="给定一个单链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。节点定义如下："></a>给定一个单链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。节点定义如下：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    ListNode *next;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>删除节点需要有被删除节点的前一节点的指针，这样才能让链表重新接起来。</p><p>但找到被删除节点的前一节点指针需要顺序查找，直到某个节点的next等于被删除节点。</p><ul><li><p>题目要求O(1)时间</p></li><li><p>换一个思路，有了被删除节点的指针，就能找到后一个节点。</p></li><li><p>我们把后一个节点p的值赋值到被删除节点进行覆盖，然后删除p，效果也相当于删除了当前需要删除的节点。</p></li><li><p>特殊情况：如果需要删除的节点是尾节点，则仍然需要从头查找，然后删除。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode *&amp;head, ListNode *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 被删除节点不是尾节点</span><br>    <span class="hljs-keyword">if</span> (p-&gt;next)<br>    &#123;<br>        ListNode *pDelete = p-&gt;next;<br>        p-&gt;m_data = pDelete-&gt;m_data;<br>        p-&gt;next = pDelete-&gt;next;<br>        <span class="hljs-keyword">delete</span> pDelete;<br>        pDelete = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head == p)<span class="hljs-comment">// 链表只有一个节点</span><br>    &#123;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = <span class="hljs-literal">nullptr</span>;<br>        head = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ListNode *q = head;<br>        <span class="hljs-keyword">while</span> (q-&gt;next != p)<br>        &#123;<br>            q = q-&gt;next;<br>        &#125;<br>        q-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打印大数</title>
    <link href="/2023/11/22/%E6%89%93%E5%8D%B0%E5%A4%A7%E6%95%B0/"/>
    <url>/2023/11/22/%E6%89%93%E5%8D%B0%E5%A4%A7%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h3><h6 id="输入数字n，按顺序打印出从1到最大的n位十进制数，由于n可能会很大，请用字符串形式打印。"><a href="#输入数字n，按顺序打印出从1到最大的n位十进制数，由于n可能会很大，请用字符串形式打印。" class="headerlink" title="输入数字n，按顺序打印出从1到最大的n位十进制数，由于n可能会很大，请用字符串形式打印。"></a>输入数字n，按顺序打印出从1到最大的n位十进制数，由于n可能会很大，请用字符串形式打印。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printBigDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> *number = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(number, <span class="hljs-string">&#x27;0&#x27;</span>, n);<br>    number[n] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 没溢出</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">addNum</span>(number) == <span class="hljs-literal">false</span>)<br>    &#123;<br>        <span class="hljs-built_in">printNum</span>(number);<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] number;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">char</span> *number)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> isOverFlow = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> upDigit = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(number);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-type">int</span> count = number[i] + <span class="hljs-string">&#x27;0&#x27;</span> + upDigit;<br>        <span class="hljs-comment">// 每次都从最后一位+1</span><br>        <span class="hljs-keyword">if</span> (i == len - <span class="hljs-number">1</span>)<br>        &#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-comment">// 第一位还要进位，比如n位3，最大999，首位进位需要为4，溢出</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>            &#123;<br>                isOverFlow = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 可发生进位</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 计数清零</span><br>                count = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// 向上进位，当前位变为0</span><br>                number[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                upDigit = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            number[i] = count + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">char</span> *number)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> isBeginWith0 = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(number);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-comment">// 默认0打头</span><br>        <span class="hljs-keyword">if</span> (isBeginWith0)<br>        &#123;<br>            <span class="hljs-comment">// 找到第一个不是0的字符</span><br>            <span class="hljs-keyword">if</span> (number[i] != <span class="hljs-string">&#x27;0&#x27;</span>)<br>            &#123;<br>                isBeginWith0 = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isBeginWith0 == <span class="hljs-literal">false</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, number[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>以上代码其实就是用字符串模拟了整数的加法运算</p></blockquote><h6 id="此题还有一个思路：全排列"><a href="#此题还有一个思路：全排列" class="headerlink" title="此题还有一个思路：全排列"></a>此题还有一个思路：全排列</h6><blockquote><p>加入输入的n位3，即打印0，1，2，3…999</p><p>如果进行全排列，每一位顺序从0-9选出一个数，当第一位确定数字后，设置下一位，直到设置的位数超过n</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNumRecursive</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> *number = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n + <span class="hljs-number">1</span>];<br>    number[n] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-type">int</span> maxIndex = n - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        number[<span class="hljs-number">0</span>] = i + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-comment">// 设置下一位</span><br>        <span class="hljs-built_in">recursiveCore</span>(number, maxIndex, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursiveCore</span><span class="hljs-params">(<span class="hljs-type">char</span> *number, <span class="hljs-type">int</span> maxIndex, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 当前设置的下标超出数字的位数下标</span><br>    <span class="hljs-keyword">if</span> (index == maxIndex + <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printNum</span>(number);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        number[index] = i + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-built_in">recursiveCore</span>(number, maxIndex, index + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剪绳子</title>
    <link href="/2023/11/20/%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <url>/2023/11/20/%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h3><h6 id="给你一根长度为n的绳子，请把绳子剪成m段（m、n都为整数），每段绳子的长度记为k-0-、k-1-…k-m-。问k-0-k-1-k-2-…k-m-的最大乘积是多少。"><a href="#给你一根长度为n的绳子，请把绳子剪成m段（m、n都为整数），每段绳子的长度记为k-0-、k-1-…k-m-。问k-0-k-1-k-2-…k-m-的最大乘积是多少。" class="headerlink" title="给你一根长度为n的绳子，请把绳子剪成m段（m、n都为整数），每段绳子的长度记为k[0]、k[1]…k[m]。问k[0]k[1]k[2]…k[m]的最大乘积是多少。"></a>给你一根长度为n的绳子，请把绳子剪成m段（m、n都为整数），每段绳子的长度记为k[0]、k[1]…k[m]。问k[0]k[1]k[2]…k[m]的最大乘积是多少。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>长度为n的绳子，切第一刀有n-1中选择，切出来的绳子可能的长度为1，2，3，4，n-1。</p><p>记f(n)是最大得到乘积，那么f(n) &#x3D; max(f(i)×f(n-i))。</p><ul><li><p>首先考虑长度为1时，切不了，最大乘积就为1。</p></li><li><p>长度为2时，只能切成1和1，最大乘积为1。</p></li><li><p>长度为3时，可以切成1，1，1和1，2，最大乘积为2.</p></li><li><p>长度为4时</p><ul><li>可以切成（1，3），（2，2），（3，1），最大f(4) &#x3D; max(f(i)×f(n-i))，i &#x3D; 1，2，3</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProductRope</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不能切</span><br>    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 当长度大于等于4时</span><br>    <span class="hljs-type">int</span> *products = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[length + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 不切就是n*0</span><br>    products[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 切一个1，就是n-1*1</span><br>    products[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 切一个2，就是n-2*2</span><br>    products[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 切一个3，就是n-3*3</span><br>    products[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= length; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// j初始化为1表示至少切一刀，切到一半，因为后面都是重复运算</span><br>        <span class="hljs-comment">// 例如7，（1，6）、（2，5）、（3，4），再往下（4，3）就开始重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; i &lt;= i / <span class="hljs-number">2</span>; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> temp = products[i] * products[i - j];<br>            <span class="hljs-keyword">if</span> (max &lt; temp)<br>            &#123;<br>                max = temp;<br>            &#125;<br>        &#125;<br>        products[i] = max;<br>    &#125;<br>    result = products[length];<br>    <span class="hljs-keyword">delete</span>[] products;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="/2023/11/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2023/11/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h3><h6 id="地上有一个m行n列的方格。一个机器人从坐标（0，0）的各自开始移动，它每次可以向左右上下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。请问机器人可以到达多少个格子。"><a href="#地上有一个m行n列的方格。一个机器人从坐标（0，0）的各自开始移动，它每次可以向左右上下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。请问机器人可以到达多少个格子。" class="headerlink" title="地上有一个m行n列的方格。一个机器人从坐标（0，0）的各自开始移动，它每次可以向左右上下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。请问机器人可以到达多少个格子。"></a>地上有一个m行n列的方格。一个机器人从坐标（0，0）的各自开始移动，它每次可以向左右上下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。请问机器人可以到达多少个格子。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>方格可以看成m行n列的矩阵。机器人从（0，0）开始移动，当他准备进入（i，j）格子时，判断检查条件。</p><ul><li><p>符合条件，则进入。接着判断上下左右相邻的格子是否可以进入。</p></li><li><p>不符合条件，则不能进入，返回到上一个格子判断其他相邻位置。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        res += num % <span class="hljs-number">10</span>;<br>        num /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> posRow, <span class="hljs-type">int</span> posCol, <span class="hljs-type">bool</span> *visited)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 未达边界，未走过，且坐标满足题设条件</span><br>    <span class="hljs-keyword">if</span> (posRow &gt;= <span class="hljs-number">0</span> &amp;&amp; posRow &lt; rows &amp;&amp; posCol &gt;= <span class="hljs-number">0</span> &amp;&amp; posCol &lt; cols &amp;&amp; visited[posRow * cols + posCol] == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-built_in">getSum</span>(posRow) + <span class="hljs-built_in">getSum</span>(posCol) &lt;= threshold)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 标志每个格子是否走过</span><br>    <span class="hljs-type">bool</span> *visited = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[rows * cols];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows * cols; i++)<br>    &#123;<br>        visited[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> count = <span class="hljs-built_in">movingCore</span>(threshold, rows, cols, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, visited);<br><br>    <span class="hljs-keyword">delete</span>[] visited;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCore</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> posRow, <span class="hljs-type">int</span> posCol, <span class="hljs-type">bool</span> *visited)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(threshold, rows, cols, posRow, posCol, visited))<br>    &#123;<br>        <span class="hljs-comment">// 将当前格子标志设置为true，表明已经走过当前格子</span><br>        visited[posRow * cols + posCol] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 考察当前格子的上下左右是否可以到达</span><br>        count = <span class="hljs-number">1</span> + <span class="hljs-built_in">movingCore</span>(threshold, rows, cols, posRow - <span class="hljs-number">1</span>, posCol, visited) <br>        + <span class="hljs-built_in">movingCore</span>(threshold, rows, cols, posRow, posCol - <span class="hljs-number">1</span>, visited)<br>        + <span class="hljs-built_in">movingCore</span>(threshold, rows, cols, posRow + <span class="hljs-number">1</span>, posCol, visited)<br>        + <span class="hljs-built_in">movingCore</span>(threshold, rows, cols, posRow, posCol + <span class="hljs-number">1</span>, visited);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="/2023/11/18/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <url>/2023/11/18/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><h6 id="把一个有序递增数组（无重复元素）的前若干元素搬到末尾称之为旋转数组，从旋转数组中找出整个数组的最小值。时间效率为O-logn"><a href="#把一个有序递增数组（无重复元素）的前若干元素搬到末尾称之为旋转数组，从旋转数组中找出整个数组的最小值。时间效率为O-logn" class="headerlink" title="把一个有序递增数组（无重复元素）的前若干元素搬到末尾称之为旋转数组，从旋转数组中找出整个数组的最小值。时间效率为O(logn)"></a>把一个有序递增数组（无重复元素）的前若干元素搬到末尾称之为旋转数组，从旋转数组中找出整个数组的最小值。时间效率为O(logn)</h6><blockquote><p>通常来说，遍历一遍数字即可获得最小值，但时间效率为O(n)</p><p>注意到，题目给出的旋转数组是有序数字变化而来，且要求时间效率为O(logn)</p><ul><li><p>考虑二分法（p头指针，q尾指针）</p></li><li><p>找出中间位置数字</p><ul><li><p>如果该数字位于前面的递增数组，则数组的最小数字应该在此数字后面，p改变到当前位置，缩小查找范围。</p></li><li><p>如果该数字位于后面的递增数组，则数组的最小数字应该在此数字前面，q改变到当前位置，缩小查找范围。</p></li><li><p>当p、q指向相邻的两个数组，此时p肯定指向了前面递增数组的最大值，而q指向了后面数组的最小值，也是整个数组的最小值。</p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (arr[low] &gt; arr[high])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (high - low == <span class="hljs-number">1</span>)<br>        &#123;<br>            mid = low;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[low])<br>        &#123;<br>            low = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; arr[high])<br>        &#123;<br>            mid = high;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[mid];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>员工年龄排序</title>
    <link href="/2023/11/17/%E5%91%98%E5%B7%A5%E5%B9%B4%E9%BE%84%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/11/17/%E5%91%98%E5%B7%A5%E5%B9%B4%E9%BE%84%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="员工年龄排序"><a href="#员工年龄排序" class="headerlink" title="员工年龄排序"></a>员工年龄排序</h3><h6 id="对公司所有员工（几万人）进行排序，年龄在0-99岁，要求时间效率为O-n-，辅助空间不得超过O-n"><a href="#对公司所有员工（几万人）进行排序，年龄在0-99岁，要求时间效率为O-n-，辅助空间不得超过O-n" class="headerlink" title="对公司所有员工（几万人）进行排序，年龄在0-99岁，要求时间效率为O(n)，辅助空间不得超过O(n)"></a>对公司所有员工（几万人）进行排序，年龄在0-99岁，要求时间效率为O(n)，辅助空间不得超过O(n)</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>题目中年龄在0-99岁，也就是说排序区间是0-99</p><p>员工有几万人，也就是说可能有很多个人具有相同的年龄。</p><p>可以对每个年龄进行计数，然后按照0-99的顺序进行排序，如果年龄出现多次则依次排序不分先后。</p><p>相当于有几万个数字，这些数字范围在0-99，对这些数字进行排序。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">srotAge</span><span class="hljs-params">(<span class="hljs-type">int</span> ages[], <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (ages == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> minAge = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> maxAge = <span class="hljs-number">99</span>;<br>    <span class="hljs-type">int</span> timesOfAge[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= maxAge; i++)<br>    &#123;<br>        timesOfAge[i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计每个年龄出现的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        timesOfAge[ages[i]]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 0-99进行排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= maxAge; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; timesOfAge[i]; j++)<br>        &#123;<br>            ages[index] = i;<br>            index++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2023/11/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/11/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>快速排序采用分治的思想，从部分有序到整体有序。</p><ul><li><p>从一个无序数组中取出第一个数字arr[0]</p></li><li><p>p指向arr[1]，q指向arr[n-1]</p></li><li><p>从q寻找到一个比arr[0]小的元素，交换p、q所指数字，使得小的数字整体位于前半部分；从p寻找到一个比arr[0]大的元素，交换p、q所指数字，使得大的数字整体位于后半部分。</p></li><li><p>当p和q相遇，则arr[0]暂时放入相遇的位置pos，此时该位置前面的数字都小于arr[0]，该位置后面的元素都大于arr[0]。</p></li><li><p>然后按照同样的逻辑在[p，pos-1]之间以及[pos+1，n-1]之间进行排序。</p></li><li><p>直到区间长度为1，此时所有的数字都满足该数字之前都小于该数字，该数字之后都大于该数字，从而使得整体有序。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[left];<br>    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot)<br>    &#123;<br>        right--;<br>    &#125;<br>    <span class="hljs-comment">// 小的移到前半部分</span><br>    arr[left] = arr[right];<br>    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt; pivot)<br>    &#123;<br>        left++;<br>    &#125;<br>    <span class="hljs-comment">// 大的移到后半部分</span><br>    arr[right] = arr[left];<br>    <span class="hljs-comment">// 相遇位置放枢轴</span><br>    arr[left] = pivot;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high)<br>    &#123;<br>        <span class="hljs-comment">// 相遇位置</span><br>        <span class="hljs-type">int</span> pos = <span class="hljs-built_in">partition</span>(arr, low, high);<br>        <span class="hljs-comment">// 相同逻辑排左边</span><br>        <span class="hljs-built_in">sort</span>(arr, low, pos - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 相同逻辑排右边</span><br>        <span class="hljs-built_in">sort</span>(arr, pos + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right)<br>    &#123;<br>        <span class="hljs-type">int</span> low = left;<br>        <span class="hljs-type">int</span> high = right;<br>        <span class="hljs-comment">// 枢轴</span><br>        <span class="hljs-type">int</span> pivot = arr[left];<br><br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt; pivot)<br>        &#123;<br>            high--;<br>        &#125;<br>        <span class="hljs-comment">// 小的移到前半部分</span><br>        arr[low] = arr[high];<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt; pivot)<br>        &#123;<br>            low++;<br>        &#125;<br>        <span class="hljs-comment">// 大的移到后半部分</span><br>        arr[high] = arr[low];<br>        <span class="hljs-comment">// 相遇位置放枢轴</span><br>        arr[low] = pivot;<br>        <span class="hljs-built_in">quickSort</span>(arr, left, low - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, low + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青蛙跳台阶</title>
    <link href="/2023/11/15/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <url>/2023/11/15/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h3><h6 id="一只青蛙可以一次跳一级台阶，也可以一次跳两级台阶。求该青蛙跳上一个n级台阶总共有多少中跳法。"><a href="#一只青蛙可以一次跳一级台阶，也可以一次跳两级台阶。求该青蛙跳上一个n级台阶总共有多少中跳法。" class="headerlink" title="一只青蛙可以一次跳一级台阶，也可以一次跳两级台阶。求该青蛙跳上一个n级台阶总共有多少中跳法。"></a>一只青蛙可以一次跳一级台阶，也可以一次跳两级台阶。求该青蛙跳上一个n级台阶总共有多少中跳法。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><ul><li><p>青蛙跳上一级台阶，只有一种跳法（跳一级）</p></li><li><p>青蛙跳上二级台阶，有两种跳法（直接跳两级或者跳两次一级）</p></li><li><p>青蛙跳上n级台阶</p><ul><li><p>可以从n-1级台阶跳一级到n级</p></li><li><p>可以从n-2级台阶跳两级到n级</p></li></ul></li><li><p>跳上n级台阶的跳法就是跳上n-1级台阶和跳上n-2级台阶的跳法总和</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fragJump</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fragJump</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fragJump</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fragJumpLoop</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> preOne = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> preTwo = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)<br>    &#123;<br>        result = preOne + preTwo;<br>        preTwo = preOne;<br>        preOne = result;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个队列实现栈</title>
    <link href="/2023/11/13/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/2023/11/13/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="两个队列实现栈"><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h3><h6 id="用两个队列模拟栈的功能"><a href="#用两个队列模拟栈的功能" class="headerlink" title="用两个队列模拟栈的功能"></a>用两个队列模拟栈的功能</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>按照栈后进先出的特点，当元素进入一个队列，出队列的时候就必须将前面的元素放入另一个队列，将最后一个元素输出（最后一个元素就是最后进入的元素），这样才符合后进先出。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStack</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CStack</span>(<span class="hljs-type">void</span>);<br>    ~<span class="hljs-built_in">CStack</span>(<span class="hljs-type">void</span>);<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CStackPush</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;data)</span></span>;<br>    <span class="hljs-function">T <span class="hljs-title">CStackPop</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    queue&lt;T&gt; q1;<br>    queue&lt;T&gt; q2;<br>    queue&lt;T&gt; *in;<br>    queue&lt;T&gt; *out;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> CStack&lt;T&gt;::<span class="hljs-built_in">CStackPush</span>(<span class="hljs-type">const</span> T &amp;elem)<br>&#123;<br>    in-&gt;<span class="hljs-built_in">push</span>(elem);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T CStack&lt;T&gt;::<span class="hljs-built_in">CStackPop</span>()<br>&#123;<br>    <span class="hljs-comment">// 将队列1中最后一个元素前面的元素移动到队列2</span><br>    <span class="hljs-keyword">while</span> (in-&gt;<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>    &#123;<br>        out-&gt;<span class="hljs-built_in">push</span>(in-&gt;<span class="hljs-built_in">front</span>());<br>        in-&gt;<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-comment">//最后一个元素出队列，也就是栈的最后一个元素先出栈</span><br>    T res = in-&gt;<span class="hljs-built_in">front</span>();<br>    in-&gt;<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-comment">// 此时交换队列1和2的角色</span><br>    <span class="hljs-built_in">swap</span>(in, out);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个栈实现队列</title>
    <link href="/2023/11/12/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2023/11/12/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><h6 id="用两个栈模拟一个队列"><a href="#用两个栈模拟一个队列" class="headerlink" title="用两个栈模拟一个队列"></a>用两个栈模拟一个队列</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>栈的特点：后进先出</p><p>队列的特点：先进先出</p><p>题目给出两个栈：一个栈压入元素后，出栈时先把元素重新压入另一个栈，则原本在后面的元素又变成了在前面的元素，此时再出栈，则满足队列的特点。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CQueue</span>(<span class="hljs-type">void</span>);<br>    ~<span class="hljs-built_in">CQueue</span>(<span class="hljs-type">void</span>);<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;node)</span></span>;<br>    <span class="hljs-function">T <span class="hljs-title">delteHead</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;T&gt; stack1;<br>    stack&lt;T&gt; stack2;<br>&#125;;<br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> CQueue&lt;T&gt;::<span class="hljs-built_in">appendTail</span>(<span class="hljs-type">const</span> T &amp;elem)<br>&#123;<br>    stack1.<span class="hljs-built_in">push</span>(elem);<br>&#125;<br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T CQueue&lt;T&gt;::<span class="hljs-built_in">delteHead</span>()<br>&#123;<br>    <span class="hljs-comment">// 当栈2不为空时，不能将栈1的元素压入，必须等到前一批输入全部出栈，这样才符合先进先出</span><br>    <span class="hljs-keyword">if</span> (stack2.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (stack1.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            T data = stack1.<span class="hljs-built_in">top</span>();<br>            stack1.<span class="hljs-built_in">pop</span>();<br>            stack2.<span class="hljs-built_in">push</span>(data);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (stack2.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;empty&quot;</span>;<br>    &#125;<br><br>    T head = stack2.<span class="hljs-built_in">top</span>();<br>    stack2.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的下一个节点</title>
    <link href="/2023/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2023/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="找出二叉树的下一个节点"><a href="#找出二叉树的下一个节点" class="headerlink" title="找出二叉树的下一个节点"></a>找出二叉树的下一个节点</h3><h6 id="给定一颗二叉树喝其中的一个节点，如何找出中序遍历的下一个节点？树中除了有两个分别指向左右子节点的指针，还有一个指向父节点的针织。"><a href="#给定一颗二叉树喝其中的一个节点，如何找出中序遍历的下一个节点？树中除了有两个分别指向左右子节点的指针，还有一个指向父节点的针织。" class="headerlink" title="给定一颗二叉树喝其中的一个节点，如何找出中序遍历的下一个节点？树中除了有两个分别指向左右子节点的指针，还有一个指向父节点的针织。"></a>给定一颗二叉树喝其中的一个节点，如何找出中序遍历的下一个节点？树中除了有两个分别指向左右子节点的指针，还有一个指向父节点的针织。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryTreeNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    BinaryTreeNode *left;<br>    BinaryTreeNode *right;<br>    BinaryTreeNode *parent;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><ul><li><p>如果所给节点有右子树，则所给节点的下个节点就是它右子树的最左下节点，沿右子树的左节点指针一直向下寻找，直到为空。</p></li><li><p>如果所给节点没有右子树</p><ul><li><p>如果所给节点是它父节点的左子节点，则它的下一节点就是其父节点。</p></li><li><p>如果所给节点是它父节点的右子节点，则沿着父节点指针向上，直到找到一个节点是它父节点的左子节点，则所找到的节点就是所给节点的下一节点。</p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BinaryTreeNode *<span class="hljs-title">nextNode</span><span class="hljs-params">(BinaryTreeNode *node)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    BinaryTreeNode *pNext = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 右节点存在，则下一节点就是右子树的最左下节点</span><br>    <span class="hljs-keyword">if</span> (node-&gt;right)<br>    &#123;<br>        BinaryTreeNode *p = p-&gt;right;<br>        <span class="hljs-keyword">while</span> (p)<br>        &#123;<br>            p = p-&gt;left;<br>        &#125;<br>        pNext = p;<br>    &#125;<br>    <span class="hljs-comment">// 右节点不存在</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;parent)<br>        &#123;<br>            <span class="hljs-comment">// 所给节点是它父节点的左子节点，按照中序遍历，它的下一节点就是它的父节点</span><br>            <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left)<br>            &#123;<br>                pNext = node-&gt;parent;<br>            &#125;<br>            <span class="hljs-comment">// 所给节点是它父节点的右子节点</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                BinaryTreeNode *cur = node;<br>                BinaryTreeNode *pParent = node-&gt;parent;<br>                <span class="hljs-keyword">while</span> (pParent &amp;&amp; cur != pParent-&gt;left)<br>                &#123;<br>                    cur = pParent;<br>                    pParent = pParent-&gt;parent;<br>                &#125;<br>                <span class="hljs-comment">// 如果是因为pParent == nullptr跳出循环，则说明所给节点是整个中序遍历中的最后一个节点，它的下一个节点为空</span><br>                <span class="hljs-comment">// 如果是因为cur == pParent-&gt;left跳出循环，则说明所给节点的位于左子树，它的下一节点是其某个祖先</span><br>                pNext = pParent;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pNext;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重建二叉树</title>
    <link href="/2023/11/09/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/11/09/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><h6 id="输入某二叉树的前序遍历和中序遍历结果，请重建这颗二叉树。加入输入的前序遍历和中序遍历结果中都不含重复的数字。二叉树节点的定义如下："><a href="#输入某二叉树的前序遍历和中序遍历结果，请重建这颗二叉树。加入输入的前序遍历和中序遍历结果中都不含重复的数字。二叉树节点的定义如下：" class="headerlink" title="输入某二叉树的前序遍历和中序遍历结果，请重建这颗二叉树。加入输入的前序遍历和中序遍历结果中都不含重复的数字。二叉树节点的定义如下："></a>输入某二叉树的前序遍历和中序遍历结果，请重建这颗二叉树。加入输入的前序遍历和中序遍历结果中都不含重复的数字。二叉树节点的定义如下：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryTreeNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    BinaryTreeNode *left;<br>    BinaryTreeNode *right;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>对于前序遍历，第一个数字总是树的根节点。对于中序遍历，根节点在序列的中间，左子树在根节点的左边，右子树在根节点的右边。</p><ul><li><p>首先根据前序遍历确定根节点</p></li><li><p>从中序遍历中找出根节点，进而找到左、右子树的序列</p></li><li><p>再用同样的方法构建左子树和右子树</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BinaryTreeNode *<span class="hljs-title">construct</span><span class="hljs-params">(<span class="hljs-type">int</span> preorder[], <span class="hljs-type">int</span> inorder[], <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (preorder == <span class="hljs-literal">nullptr</span> || inorder == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">constructCore</span>(preorder, preorder + length - <span class="hljs-number">1</span>, inorder, inorder + length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function">BinaryTreeNode *<span class="hljs-title">constructCore</span><span class="hljs-params">(<span class="hljs-type">int</span> *beginPre, <span class="hljs-type">int</span> *endPre, <span class="hljs-type">int</span> *beginIn, <span class="hljs-type">int</span> *endIn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> rootData = *beginPre;<br>    BinaryTreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryTreeNode</span>();<br>    root-&gt;m_data = rootData;<br>    root-&gt;left = <span class="hljs-literal">nullptr</span>;<br>    root-&gt;right = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">if</span> (beginPre == endPre)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (beginIn == endIn &amp;&amp; *beginPre == *beginIn)<br>        &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 输入有误</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 在中序遍历中找根节点</span><br>    <span class="hljs-type">int</span> *rootInorder = beginIn;<br>    <span class="hljs-keyword">while</span> (rootInorder &lt;= endIn &amp;&amp; *rootInorder != rootData)<br>    &#123;<br>        rootInorder++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rootInorder == endIn &amp;&amp; *rootInorder != rootData)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> leftTreeLength = rootInorder - beginIn;<br>    <span class="hljs-type">int</span> *leftTreeEnd = beginPre + leftTreeLength;<br><br>    <span class="hljs-keyword">if</span> (leftTreeLength &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 存在左子树</span><br>    &#123;<br>        root-&gt;left = <span class="hljs-built_in">constructCore</span>(beginPre + <span class="hljs-number">1</span>, leftTreeEnd, beginIn, rootInorder - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (leftTreeLength &lt; endPre - beginPre) <span class="hljs-comment">// 存在右子树</span><br>    &#123;<br>        root-&gt;right = <span class="hljs-built_in">constructCore</span>(leftTreeEnd + <span class="hljs-number">1</span>, endPre, rootInorder + <span class="hljs-number">1</span>, endIn);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="/2023/11/04/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/11/04/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><h6 id="输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下："><a href="#输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：" class="headerlink" title="输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下："></a>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    ListNode *next;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>从尾到头打印链表中的值，也就是说最后一个节点的值要第一个输出，符合后进先出特征，可以借助栈结构来实现。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printReverse</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ListNode *p = head;<br>    stack&lt;ListNode *&gt; nodes;<br>    <span class="hljs-keyword">while</span> (p)<br>    &#123;<br>        nodes.<span class="hljs-built_in">push</span>(p);<br>        p = p-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!nodes.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        p = nodes.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, p-&gt;m_data);<br>        node.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递归本质上也是一个栈结构，也可以采用递归来实现。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printReverse</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-comment">// 判断是否已到表尾</span><br>        <span class="hljs-keyword">if</span> (head-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-built_in">printReverse</span>(head-&gt;next);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, head-&gt;m_data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="/2023/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="在二维数组中查找数字"><a href="#在二维数组中查找数字" class="headerlink" title="在二维数组中查找数字"></a>在二维数组中查找数字</h3><h6 id="在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。"><a href="#在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。" class="headerlink" title="在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。"></a>在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>思路一：</p><p>从最右上角的数字num开始</p><ul><li><p>如果寻找的数字小于num，则继续在num所在列的左边寻找</p></li><li><p>如果寻找的数字大于num，则继续在num所在行的下面寻找</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNum</span><span class="hljs-params">(<span class="hljs-type">int</span> *matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (matrix != <span class="hljs-literal">nullptr</span> &amp;&amp; rows &gt; <span class="hljs-number">0</span> &amp;&amp; cols &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 定位最右上角元素</span><br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> col = cols - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (row &lt;= rows - <span class="hljs-number">1</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (num == matrix[row * cols + col])<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; matrix[row * cols + col])<br>            &#123;<br>                col--;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                row++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路二：</p><p>从最左下角数字num开始</p><ul><li><p>如果寻找的数字大于num，则继续在num所在列的右边寻找</p></li><li><p>如果寻找的数字小于num，则继续在num所在行的上方寻找</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNum</span><span class="hljs-params">(<span class="hljs-type">int</span> *matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (matrix != <span class="hljs-literal">nullptr</span> &amp;&amp; rows &gt; <span class="hljs-number">0</span> &amp;&amp; cols &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 定位最左下角元素</span><br>        <span class="hljs-type">int</span> row = rows - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt;= cols - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (num == matrix[row * cols + col])<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; matrix[row * cols + col])<br>            &#123;<br>                col++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                row--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>替换字符串中的空格</title>
    <link href="/2023/11/02/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/"/>
    <url>/2023/11/02/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="替换字符串中的空格"><a href="#替换字符串中的空格" class="headerlink" title="替换字符串中的空格"></a>替换字符串中的空格</h3><h6 id="请实现一个函数，把字符串中的每个空格替换成”-20”-例如，输入“We-are-happy”，则输出“We-20are-20happy”。"><a href="#请实现一个函数，把字符串中的每个空格替换成”-20”-例如，输入“We-are-happy”，则输出“We-20are-20happy”。" class="headerlink" title="请实现一个函数，把字符串中的每个空格替换成”%20”.例如，输入“We are happy”，则输出“We%20are%20happy”。"></a>请实现一个函数，把字符串中的每个空格替换成”%20”.例如，输入“We are happy”，则输出“We%20are%20happy”。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>将空格替换成”%20”一定会导致字符串变长，且空格后面的字符串一定会向后移动</p><ul><li><p>统计空格的个数</p></li><li><p>计算替换空格后新字符串的长度</p></li><li><p>两个指针，一个指针p指向原始字符串的结尾，另一个指针q指向新字符串的结尾</p></li><li><p>p从后往前扫描字符串</p><ul><li><p>如果没遇到空格，则将string[q] &#x3D; string[p]，两指针同时向前移动一位</p></li><li><p>遇到空格，sring[q] &#x3D; ‘0’，string[q-1] &#x3D; ‘2’，string[q-2] &#x3D; ‘%’，p移动一位，q移动三位</p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// length为字符数组的总容量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">replaceBlank</span><span class="hljs-params">(<span class="hljs-type">char</span> string[], <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> originalLen = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> blankNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (string[i] != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#123;<br>        originalLen++;<br>        <span class="hljs-keyword">if</span> (string[i] == <span class="hljs-string">&#x27; &#x27;</span>)<br>        &#123;<br>            blankNum++;<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-type">int</span> newLen = originalLen + <span class="hljs-number">2</span> * blankNum;<br>    <span class="hljs-keyword">if</span> (newLen &gt; length)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> indexOfOringin = originalLen;<br>    <span class="hljs-type">int</span> indexOfNew = newLen;<br>    <span class="hljs-keyword">while</span> (indexOfOringin &gt;= <span class="hljs-number">0</span> &amp;&amp; indexOfOringin &lt; indexOfNew)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (string[indexOfOringin] == <span class="hljs-string">&#x27; &#x27;</span>)<br>        &#123;<br>            string[indexOfNew] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            string[indexOfNew - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            string[indexOfNew - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>            indexOfNew -= <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            string[indexOfNew] = string[indexOfOringin];<br>            indexOfNew -= <span class="hljs-number">1</span>;<br>        &#125;<br>        indexOfOringin--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中的重复数字</title>
    <link href="/2023/11/01/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/"/>
    <url>/2023/11/01/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h3><h6 id="在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。"><a href="#在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。" class="headerlink" title="在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。"></a>在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>从头到尾扫描数组array（循环），首先比较数字num和index是否相等。</p><ul><li><p>如果相等，则接着扫描下一个数字。</p></li><li><p>如果不相等，则将数字num和arr[num]比较</p><ul><li><p>如果num&#x3D;&#x3D;arr[num]，则num就是一个重复数字</p></li><li><p>如果num!&#x3D;arr[num]，则swap(num,arr[num])，将num放在属于它的位置，继续比较当前位置和交换后的数字（循环）</p></li></ul></li></ul></blockquote><p><strong>此方法修改了原始数组</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> *duplicate)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">nullptr</span> || len &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span> || nums[i] &gt; len - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;    <br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (nums[i] != i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[nums[i])<br>            &#123;<br>                *duplicate = nums[i];<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-type">int</span> temp = nums[i];<br>                nums[temp] = nums[i];<br>                nums[i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不修改数组找出重复的数字"><a href="#不修改数组找出重复的数字" class="headerlink" title="不修改数组找出重复的数字"></a>不修改数组找出重复的数字</h3><h6 id="在一个长为n-1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。"><a href="#在一个长为n-1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。" class="headerlink" title="在一个长为n+1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。"></a>在一个长为n+1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。</h6><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote><p>采用二分法</p><p>三个指针：low、mid、high</p><p>例如：{2，3，5，4，3，2，6，7}，统计整个数组中1-4和4-7的数字个数count</p><ul><li><p>如果count&gt;mid-low+1，则说明重复数字在[low，mid]范围，high &#x3D; mid</p></li><li><p>否则，重复数字在[mid，high]范围，low &#x3D; mid + 1</p></li></ul><p>直到low&#x3D;&#x3D;high</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> high = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (low &lt; high)<br>    &#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-built_in">countRange</span>(nums, length, low, high);<br>        <span class="hljs-keyword">if</span> (count &gt; mid - low + <span class="hljs-number">1</span>)<br>        &#123;<br>            high = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (low == high)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countRange</span>(nums, length, low, high) &gt; <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> low;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countRange</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> length, <span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt;= min &amp;&amp; nums[i] &lt;= max)<br>        &#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七章_初探类</title>
    <link href="/2023/09/22/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%88%9D%E6%8E%A2%E7%B1%BB/"/>
    <url>/2023/09/22/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%88%9D%E6%8E%A2%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="初探类"><a href="#初探类" class="headerlink" title="初探类"></a>初探类</h3><ul><li><p><code>class</code>与<code>struct</code></p><p>唯一的区别：默认访问权限不同</p><p>访问权限是针对类来说的，而<strong>同一个类的对象之间</strong>没有访问权限。</p><p>class：private</p><p>struct：public</p><blockquote><p>定义在类内部的成员函数是自动 inline 的</p></blockquote></li><li><p>可变数据成员</p><p>关键字：mutable</p><p>任何成员函数包括（常函数）都可以改变加被 mutable 修饰的数据成员。</p></li><li><p>从 const 成员函数返回<code>*this</code></p><p>const 成员函数返回<code>*this</code>，返回类型是常量引用，不能作为可改变的左值进行调用。</p></li></ul><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>关键字：friend</p><ul><li><p>全局函数做友元</p></li><li><p>成员函数做友元</p></li><li><p>类做友元</p></li></ul><blockquote><p>即使友元函数声明在类内，也需要在外部再声明一次</p></blockquote><h4 id="类定义处理"><a href="#类定义处理" class="headerlink" title="类定义处理"></a>类定义处理</h4><p>编译成员的声明，直到类全部可见才编译<strong>函数体</strong>（函数名属于声明）</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li><p>&#x3D;default</p><p>作用：要求编译器提供构造函数</p></li><li><p>初始值列表</p><blockquote><p>如果含有引用或者 const 的，则必须使用列表初始化。</p><p><strong>建议总是使用构造函数列表初始化。</strong></p></blockquote></li><li><p>初始化顺序</p><p>使用构造函数列表初始化没有限定初始化顺序。</p><blockquote><p>建议</p><ul><li><p>构造函数初始值顺序与成员声明顺序一致。</p></li><li><p>避免用成员初始化成员</p></li></ul></blockquote></li></ul><p><strong>如果一个构造函数为所有参数都提供了默认参数，则实际上定义了默认构造函数</strong></p><h6 id="易错"><a href="#易错" class="headerlink" title="易错"></a>易错</h6><ul><li><p>类名 obj();</p><p>obj 是一个函数而不是一个实例化的对象.</p></li><li><p>类名 obj;</p><p>obj 是一个实例化的对象.</p></li></ul><h6 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h6><ul><li><p>只允许一步类类型转换</p></li><li><p>使用 explicit 关键字抑制类类型转换，只对一个实参的构造函数有效。</p><blockquote><p>因为多个实参不能隐式转换（大于一步）</p></blockquote></li></ul><h6 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h6><ol><li><p>所有成员都是 public 的</p></li><li><p>没有构造函数</p></li><li><p>没有类内初始值</p></li><li><p>没有基类和 virtual 函数</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六章_函数</title>
    <link href="/2023/09/19/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/"/>
    <url>/2023/09/19/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h5><ul><li><p>形参与实参</p><p>实参类型要与形参类型匹配，<strong>实参可以发生隐式转换</strong>。</p><p>区分引用传递和值传递。</p></li><li><p>函数的返回类型</p><p>函数的返回类型不能是<strong>数组或函数</strong>，但可以返回指向数组或函数的指针。</p></li><li><p>局部静态对象</p><p>定义在函数内部的局部静态对象（static修饰），函数执行结束也不会销毁，但并不改变作用域。</p></li></ul><h5 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h5><ul><li><p>传引用参数</p><ol><li><p>可以避免拷贝</p></li><li><p>利用引用传递返回额外信息</p></li><li><p>const 形参</p><blockquote><p>常见错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">func</span>(string &amp;s);<span class="hljs-comment">//非常量引用无法接收字面值，除非加const</span><br><span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote></li></ol></li><li><p>数组传参</p><p>实参会自动转换为指向数组首元素的指针。</p><p>由于数组是以指针形式传递给函数的，所以不知道数组的维度，必须由调用者提供额外信息。</p><blockquote><p>解决方法：</p><ol><li><p>使用标记指定数组长度</p><p>C 风格的字符串（字符数组）</p></li><li><p>使用标准库规范</p><p>传递指向数组首元素和尾后元素的指针（迭代器的做法）</p></li><li><p>显式传递一个表示数组大小的形参</p></li></ol></blockquote></li></ul><h5 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h5><ul><li><p>值返回</p><ol><li><p>返回的值用于初始化调用点的临时量</p></li><li><p>不要返回局部对象的引用或指针</p></li><li><p>引用返回左值，例如，返回非常量引用的函数可以进行赋值操作。</p></li></ol></li><li><p>返回数组指针</p><p>由于数组不能拷贝，所以函数不能返回数组。</p><ul><li><p>定义返回数组指针的函数</p><p><code>type (*function(para))[dim]</code></p></li><li><p>尾置返回类型</p><p><code>auto func(int i) -&gt; int(*)[10]</code></p></li></ul></li></ul><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><ul><li><p>重载与 const 形参</p><p>拥有顶层的 const 形参无法与没有顶层 const 的形参区分，因此不能作为重载条件。</p><p>引用或指针的底层 const 可以作为重载条件。</p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i)</span></span><br><span class="hljs-function"></span>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;int i&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;i)</span></span><br><span class="hljs-function"></span>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;const int i&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">test</span>(j);<br><span class="hljs-comment">//j是非常量，非常量可以初始化常量，因此两个版本都能调用，但优先调用非常量引用版本</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>重载与作用域</p><p>一旦在内层作用域声明名字，它将隐藏外层作用域所有版本的函数。</p></li><li><p>函数匹配</p><ol><li><p>候选函数</p><p>与被调用的函数同名；声明在调用点可见。</p></li><li><p>可行函数</p><p>形参数量与本次调用的实参数量相同；形参与实参的类型相同，或者实参可以转换为形参的类型。</p></li><li><p>最佳匹配</p><p>精确匹配比类型转换匹配更好；</p><blockquote><p>有且仅有一个最佳匹配，否则编译器因为二义性二拒绝请求。</p></blockquote></li></ol></li></ul><h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><ul><li><p>函数指针定义</p><p>函数的类型：由其返回类型和其形参类型共同决定。</p><p>函数定义：<code>bool func(para...)</code></p><p>函数类型：<code>bool (para...)</code></p><p>函数指针：<code>bool (*p)(para...)</code></p><p>p 函数指针未初始化，p可以指向<code>bool (para...)</code>函数类型。</p><blockquote><p>当函数作为一个值使用时，该函数自动转换成指针，<code>p = func;</code>等价于<code>p = &amp;func;</code></p><p>使用函数指针调用时可以不解引用，<code>p(...)</code>等价于<code>(*p)(...)</code></p></blockquote></li><li><p>函数指针形参</p><ul><li><p>形参可以是指向函数的指针，传递函数类型时，会自动转换成函数</p><p><code>void test(bool func(para...))</code>等价于<code>void test(bool (*func)(para...))</code></p></li><li><p>实参可以直接传递函数名，它会自动转换为指针</p><p><code>test(func)</code></p></li></ul></li><li><p>返回函数指针</p><p><code>int (*f1(int))(int *, int);</code></p><p>f1 表示 f1 是一个函数类型；</p><p>*f1 表示 f1 返回指针；</p><p>*f1 还包含后面的参数列表，说明返回的指针指向函数；</p><p>返回的函数的返回类型是 int</p></li></ul><h5 id="特殊特性"><a href="#特殊特性" class="headerlink" title="特殊特性"></a>特殊特性</h5><ul><li><p>默认实参</p><p>默认实参可作为形参的初始值</p><p>一旦某个形参被赋予了默认值，则它之后的所有形参都必须有默认值。</p></li><li><p>内联函数</p><p>作用：编译器将小函数在调用点展开，达到优化的效果</p></li><li><p>constexpr 函数</p><p>作用：用于常量表达式的函数，编译阶段验证，执行初始化阶段将 constexpr 函数替换为常量。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章_语句</title>
    <link href="/2023/09/18/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AF%AD%E5%8F%A5/"/>
    <url>/2023/09/18/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><h6 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h6><ul><li><p>空语句</p><p>配合 while 循环使用</p></li><li><p>复合语句</p><p>{}包含起来</p></li><li><p>语句作用域</p><p>块作用域</p></li></ul><h6 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h6><ul><li><p>if 语句</p><p>嵌套 if 语句以及 else 悬垂的问题都可以利用花括号控制执行路径进行解决。</p></li><li><p>switch 语句</p><p>case 标签必须是整型常量表达式，每条 case 标签结束都理应加上 break 关键字，除非有特殊业务需求。</p><blockquote><p><strong>内部的变量定义细节问题</strong></p><p>由于 case 分支可能被跳过（变量初始化），后续 case 分支可能使用（同一作用域可以访问）被跳过 case 分支中定义的变量，出错。</p><p>由于不确定 switch 语句中的控制流，所以要在 case 分支中定义变量时，应该使用块作用域。</p></blockquote></li></ul><h6 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h6><ul><li><p>while 语句</p><p>不知道循环多少次或者循环结束后还需要访问循环控制变量时使用。</p></li><li><p>do-while 语句</p><p>需要用分号表示语句结束，条件部分不能定义变量。</p></li><li><p>传统 for 语句</p><ul><li><p>for 语句头多重定义</p><p>变量的基础类型必须相同，例如<code>for(int i = 0, *p = expr; expr; expr)</code></p></li><li><p>省略 for 语句头中的部分</p><p>可以省略任何一部分或者全部，省略条件部分等价于永远为 true。</p></li></ul><blockquote><p>for 语句具有块作用域</p></blockquote></li><li><p>范围 for 语句</p><p>使用时先预存 end()的值，因此不能再向容器中添加元素，否认则将导致 end()值无效。</p></li></ul><h6 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h6><ul><li><p>break 语句</p><p>负责终止最近的 while、do-while、for 和 switch 语句（没有 if 语句！！！）。</p></li><li><p>continue 语句</p><p>终止最近循环中的本次迭代，开始下一次迭代（for、while、do-while）。</p></li><li><p>异常处理</p><ul><li><p> throw 语句</p><p>throw 异常类型(字符串)</p></li><li><p>try 语句</p><p>花括号内属于块作用域，catch 也不能访问。</p></li><li><p>catch 语句</p><p>catch 语句括号内跟一个异常类型声明。</p><p>try 语句之后可能会跟多个 catch，直到 catch 捕捉到对应的异常类型，然后跳过所有 catch 语句执行。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章 表达式</title>
    <link href="/2023/09/17/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/09/17/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><ul><li><p>左值和右值</p><p><strong>当一个对象被用作右值时，用的是对象的值（内容）；被用作左值时，用的是对象的身份（在内存中的位置）</strong></p><blockquote><p>在需要右值的地方可以用左值替代，使用左值的内容。</p><p><strong>但是不能把右值当作左值使用。</strong></p></blockquote></li><li><p>优先级</p><p>规定运算对象的组合方式，括号无视优先级。</p></li><li><p>求值顺序</p><p>求值顺序与优先级和结合律无关。</p><p>在一条复合语句中，如果出现多个求值表达式，同时它们会改变同一对象的状态，则它会产生未定义的行为。</p><blockquote><p><code>f()+g()*h()+j();</code>，没有严格的调用顺序，如果每个函数都在内部对某个对象的状态进行改变，那么不同的调用顺序会产生不同的结果。</p><p><strong>如果改变了某个运算对象的值，在表达式的其他地方就不要再使用这个运算对象</strong></p></blockquote></li></ul><h6 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h6><ul><li><p>算术运算符</p><ul><li><p>取余运算</p><p>取余运算的运算对象必须是整数类型。</p><p>运算结果的符号匹配第一个数字的符号，<code>m%n</code>的结果符号与 m 的符号相同。</p></li></ul></li><li><p>逻辑运算符</p><ul><li><p>短路求值&amp;&amp;和||</p><p>先求左侧运算对象的结果再求右侧运算对象的结果，<strong>当左侧结果无法确定表达式的结果时才求右侧结果</strong>。</p><blockquote><p>左侧运算对象可以保证右侧运算对象求值过程的正确性和安全性，例如下标是否有效&amp;&amp;依下标访问对象</p></blockquote></li></ul></li><li><p>关系运算符</p><p><code>if(i &lt; j &lt; k);</code>错误；<code>if(i &lt; j &amp;&amp; j &lt; k);</code>正确</p><p>避免使用布尔字面值作为运算对象，例如<code>if(val == true)</code>，true 会转换为 1。</p></li><li><p>赋值运算符</p><p>赋值结果返回的是左侧运算对象，且是一个左值。</p><p>如果左右侧运算对象类型不同，则<strong>右侧运算对象将转为左侧运算对象类型</strong></p><blockquote><p>如果在一个赋值表达式的左右两边使用同一运算对象，避免出现改变该对象的做法，例如<code>*p = toupper(*p++);</code></p></blockquote></li><li><p>递增和递减运算符</p><blockquote><p>建议使用前置版本，效率高，但主流编译器都会将后置优化为前置。</p><p>如果需要用到改变前的值，则使用后置版本</p></blockquote></li><li><p>sizeof</p><ul><li><p>sizeof(type)，返回指定类型的大小。</p></li><li><p>sizeof expr，返回表达式结果类型的大小。</p></li></ul></li></ul><h6 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h6><ul><li><p>隐式转换</p><ol><li><p>算术转换，为了保证精度；int-&gt;float</p></li><li><p>初始化时，初始值转换为变量的类型；赋值时，右侧运算对象转换为左侧运算对象的类型。</p></li><li><p>一般情况下，有符号类型转换为无符号类型（具有不定性，不建议）。</p></li><li><p>数组转换为指针，函数传参。<strong>特殊的，sizeof是运算符，不会发生此转换</strong>。</p></li><li><p>指针转换</p><p>常量 0 和字面量 nullptr 可以转换成任意指针类型。</p><p>指向任意非常量的指针能转换成<code>void*</code>；指向任意对象的指针能转换成<code>const void*</code></p></li><li><p>转换成常量(const)</p><p>非常量转化为常量引用或者顶层 const 指针。</p></li><li><p>类类型定义转换</p><p>string 对象与字符串字面量</p></li></ol></li><li><p>显式转换</p><p>cast-name<type>(expr)</p><ul><li><p>static_cast</p><p>将expr转换为type，但不能转换掉expr的const属性。</p><blockquote><p>static_cast常用于非多态类型之间的转换。</p></blockquote></li><li><p>dynamic_cast</p><p>将expr转换为type，type必须是类的指针、类的引用或者是void *；如果type是指针类型，那么expr也必须是一个指针；如果type是一个引用，那么expr也必须是一个引用。</p><blockquote><p>dynamic_cast常用于多态类型之间的转换。</p></blockquote></li><li><p>const_cast</p><p>去掉 const 性质（常量对象转换为非常量对象，只改变常量属性）。</p><p>例如，<code>const char *p;</code> <code>char *p1 = const_cast&lt;char *&gt;(p)</code></p></li><li><p>reinterpret_cast</p><p>允许将任意指针转换到其他指针类型，也允许做任意整数类型和任意指针类型之间的转换。转换时，执行的是逐个比特复制的操作。reinterpret中文意为“重新解释; 重新诠释;”。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 迭代器基础</title>
    <link href="/2023/09/16/%E7%AC%AC%E4%B8%89%E7%AB%A0_%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/09/16/%E7%AC%AC%E4%B8%89%E7%AB%A0_%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h3><p>行为类似于指针，迭代器也提供了对对象进行间接访问<br>所有标准库容器都支持迭代器，string 不属于容器但也支持迭代器</p><ul><li>使用迭代器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> start = v.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//第一个元素的迭代器</span><br><span class="hljs-keyword">auto</span> end = v.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//尾后迭代器（尾元素的下一个位置）</span><br></code></pre></td></tr></table></figure><p><strong>通过迭代器修改元素，效果与引用或指针一样</strong><br>迭代器也可以通过递增操作实现访问下一元素，最多移动到尾后迭代器<br>迭代器判断使用<code>!=</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; endl; <span class="hljs-comment">//类似指针解引用，箭头运算符也可以使用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>迭代器类型<ol><li>iterator<br>可读可写</li><li><code>const_iterator</code>（类似于指针常量）<br>可读不可写</li><li><code>cbegin</code> 和 <code>cend</code><br>返回 <code>const_iterator</code> 类型<br><strong>在循环体使用了迭代器，不能向迭代器所属的容器中添加元素，否则会导致迭代器失效</strong></li></ol></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h3><ul><li>定义与初始化</li></ul><ol><li><p>定义</p><p>数组是复合类型，包含数组名和数组维度</p><p>其中数组维度<em>必须是常量表达式</em></p><p>不允许使用 auto 关键字来推断数组的类型</p></li><li><p>初始化</p><p>指明维度，初始值的总数量就不应该超过维度，若还有剩，则剩下的用默认初始值。</p><p>不指明维度，维度大小由列表初始值数量确定。</p></li><li><p>字符数组</p><p>若用字符串字面值（非 string 对象）初始化字符数组，则字符数组会多占用一个位置放<code>&#39;\0&#39;</code> 作为结尾标志，这也是 C 风格的字符串。</p></li><li><p>复杂的数组声明！！！</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *ptrs[<span class="hljs-number">10</span>];<span class="hljs-comment">//ptrs是含有是个整型指针的数组</span><br><span class="hljs-built_in">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr;<span class="hljs-comment">//Parray指向一个含有10个整数的数组，定义数组的指针</span><br><span class="hljs-built_in">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr;<span class="hljs-comment">//arrRef是含有10个整数数组的引用</span><br><span class="hljs-type">int</span> *(&amp;array)[<span class="hljs-number">10</span>] = ptrs;<span class="hljs-comment">//array是含有10个整数指针数组的引用</span><br></code></pre></td></tr></table></figure><p><strong>从数组名字开始从内向外阅读</strong></p><ul><li><p>访问数组元素</p><p>数组除了大小固定之外，其他用法与 vector 类似。例如通过下标运算符[]访问。</p><p>范围 for 可以实现数组遍历，使用范围 for 是因为系统知道数组的维度（维度属于数组类型的一部分）</p><p><strong>下标的范围由程序员自行检查</strong></p></li><li><p>指针与数组</p><p>数组名字就是指向数组首元素的指针</p><ul><li><p>指针也是迭代器</p><p>通过数组名字得到指向首元素的指针</p><p>通过<code>&amp;arr[size]</code>得到尾后元素的指针</p><p>begin 和 end 函数（iterator 头文件中），begin 返回数组的首元素指针，end 返回数组的尾后元素指针。</p></li></ul></li><li><p>数组初始化 vector 对象</p><p><code>vector&lt;int&gt; ivec(begin(arr), end(arr));</code></p><p>不包含<code>end(arr)</code>位置上的值（左闭右开区间），也可以用部分值来初始化 vector 对象</p><p><strong>尽可能使用 vector 和迭代器，避免使用数组和指针；使用 string 对象，避免使用字符数组。</strong></p></li><li><p>多维数组</p><p>范围 for 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;row : arr)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;col : row)<br></code></pre></td></tr></table></figure><p>使用范围 for 循环时，除了最内层的循环外，其他循环都应该是引用类型（<strong>避免编译器将数组形式的元素转换为指向该数组内首元素的指针</strong>）</p></li></ul><h3 id="string对象"><a href="#string对象" class="headerlink" title="string对象"></a>string对象</h3><h6 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h6><ul><li><p>读写对象</p><p><code>cin &gt;&gt; str;</code>，将标准输入的内容读到 str 对象中，从第一个有效字符开始直到空白（空格、换行等）。</p></li><li><p>getline 读取一整行</p><p><code>getline(cin, str)</code>可以保留输入中的空白符。</p><blockquote><p>一直读到换行符为止（换行符也读进去了，但返回时会被丢掉，不存如str），然后存入 string 对象中（不存换行符）。</p></blockquote></li><li><p>字面值和 string 对象相加</p><p>字面值之间是不能拼接的，例如<code>string s = &quot;hello&quot; + &quot;world&quot;;</code>，这是错误的。</p><p>加号两边至少有一个是 string 对象才能实现字面值和 string 对象的拼接。</p></li></ul><h6 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h6><ul><li><p>范围for</p><p>作用：对于 string 对象中的每一个字符（迭代得到）执行操作（要想改变原字符串需要加引用）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str)<br>    statement;<br></code></pre></td></tr></table></figure></li><li><p>下标运算符[]</p><p>参数：字符的 index</p><p>返回值：index 处字符的引用</p><p><strong>使用超出范围的下标会引发不可预知的结果</strong></p></li></ul><h3 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h3><p><code>vector&lt;T&gt;;</code>，T 表示容器中潜在元素对象的类型。</p><ul><li><p>初始化操作</p><ul><li><p>列表初始化</p><p><code>vector&lt;string&gt; v1&#123;&quot;a&quot;,&quot;an&quot;,&quot;the&quot;&#125;;</code>，只能使用花括号，不能使用圆括号。</p></li><li><p>值初始化</p><p><code>vector&lt;int&gt; v1(10);</code>，表示用 10 个 int 类型的元素初始值，由类型决定（默认初始化）。<strong>对于不存在默认初始化的类，必须提供初始值。</strong></p></li><li><p>辨析{}和()</p><p>()中提供的值是用来构造 vector 对象的，潜在对象执行T类型的默认初始化。</p><p>{}总是尽可能按照列表初始化来处理提供的值（处理潜在对象），只有在不能进行列表初始化时才用来构造对象。</p></li></ul></li><li><p>向容器中添加元素</p><ul><li><p>vector 对象能高效增长</p></li><li><p><code>push_back</code> 添加元素</p><p>功能：把一个值当作 vector 对象的尾元素压入到尾部。</p><p><strong>如果循环体内有向 vector 对象中添加元素的操作，则不能使用范围 for 循环</strong></p></li><li><p>下标运算符不能用于添加元素</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 变量与基本类型</title>
    <link href="/2023/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/09/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h3><p><strong>变量定义</strong><br>类型说明符 变量名 &#x3D; 初始值</p><blockquote><p>注意：初始化和赋值的区别<br>初始化：创建变量的时候赋予其一个初始值<br>赋值：把对象的当前值擦除，用新值来替代</p></blockquote><p><strong>初始化</strong></p><ol><li><p>列表初始化<br>例如：①int i &#x3D; 0; ②int i(0) ③int i{0}<br>② 如果用变量来初始化，可能会丢失精度，但可以初始化成功<br>③ 是 C++11 的特性，如果会丢失精度，编译器会报错，初始化失败</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-number">3.14</span>)</span></span>;<br>    cout &lt;&lt; i &lt;&lt; endl; <span class="hljs-comment">//3</span><br>    <span class="hljs-type">int</span> j&#123;<span class="hljs-number">3.14</span>&#125;; <span class="hljs-comment">//编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>默认初始化<br>定义在任何<strong>函数体之外</strong>的变量被初始化为 0<br>定义在<strong>函数体内部的内置类型变量</strong>将不被初始化（但不同编译器做法不同）<br>类可以自主决定初始化对象的方式（构造函数）<br><strong><em>建议初始化每一个内置类型的变量</em></strong></p></li></ol><p><strong>声明与定义</strong><br>声明：规定变量的类型和名，不会默认初始化，而是未定义<br>定义：除声明所做事情之外，还会创建与名字关联的实体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;       <span class="hljs-comment">//声明</span><br><span class="hljs-type">int</span> j;              <span class="hljs-comment">//定义</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;   <span class="hljs-comment">//定义（显示初始化的声明会成为定义，函数体内部不能用）</span><br></code></pre></td></tr></table></figure><p><strong>变量只能被定义一次，但可以声明多次（定义出现在某一个文件中，其他文件只能对其进行声明）</strong></p><p><strong>引用和指针</strong></p><ul><li><p>引用<br>引用始终和它的初始值（只能是对象）绑定在一起（之后无法改变），因此<strong>定义引用的时候必须初始化且不能是例如字面值之类的非对象初始值</strong></p><p>操作引用实际上就是在操作与之绑定的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> &amp;ref1;        <span class="hljs-comment">//错误，未初始化</span><br>    <span class="hljs-type">int</span> &amp;ref2 = <span class="hljs-number">1024</span>; <span class="hljs-comment">//错误，绑定的不是对象，而是字面值</span><br><br>    <span class="hljs-type">int</span> value = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">int</span> &amp;ref3 = value;<br>    ref3 = <span class="hljs-number">2048</span>;<br>    cout &lt;&lt; value &lt;&lt; endl; <span class="hljs-comment">// 2048，引用就是被绑定对象的别名</span><br>    cout &lt;&lt; ref3 &lt;&lt; endl;  <span class="hljs-comment">// 2048</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>引用本身不是一个对象，因此不能定义引用的引用</strong><br>引用类型要与初始化对象类型对应</p></blockquote></li><li><p>指针<br>指针保存对象的地址，同时指针本身也是一个对象，可以重复赋值，也可以被引用绑定。<br>获取一个对象的地址使用<code>&amp;</code>，用对应类型的指针接收<br>有效的指针通过解引用<code>*p</code>来访问指向的对象</p><blockquote><p>空指针，<code>int *p = nullptr;</code><br>建议初始化所有指针，因为不知道指向了那一块内存，使用时可能会出现访存错误。<br><code>void*</code>指针，只是单纯存放一个内存地址，由于不知道此地址存放的对象的类型，可以进行的操作有限。</p></blockquote></li><li><p>对指针的引用<br><code>int *&amp;pi = p;</code><br>从右往左阅读，首先<code>&amp;pi</code> 是一个引用，对<code>int *</code>的引用，也就是对指针的引用。</p></li></ul><p><strong><code>const</code> 限定符</strong></p><p>作用：不允许<code>const</code>修饰的对象重新赋值</p><ul><li><p>初始化<br><code>const</code>对象一旦创建后其值不能再改变，因此必须进行初始化。<br>可以用普通对象对<code>const</code>对象进行初始化，也可以用 <code>const</code> 对象初始化普通对象（调用 operator&#x3D;）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> j = i; <span class="hljs-comment">// j的常量特性只在执行改变j时发挥作用</span><br>    <span class="hljs-type">int</span> k = j;       <span class="hljs-comment">//合理，k拷贝j的值并不会改变j</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>extern 的利用<br><code>const int buffSize = 512;</code>，<em>编译器在编译的时候将所有 <code>buffSize</code> 替换为 512。</em><br><strong><code>const</code>对象被设定为只在文件内有效</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//file_1.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffSize = <span class="hljs-built_in">func</span>();       <br><span class="hljs-comment">//file_1.h</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffSize;                <span class="hljs-comment">//extern限定使常量成为外部链接</span><br></code></pre></td></tr></table></figure><p><strong>多个文件共享<code>const</code>对象需要在 <code>const</code> 对象的定义前加 extern</strong></p></li><li><p>常量引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1024</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = a;<br></code></pre></td></tr></table></figure><p>如果被引用的对象不可变，由于引用是别名（改变引用会改变绑定的对象），所以引用也不能变。</p></li><li><p>常量引用的初始化<br>与一般的引用不同，常量引用可以用非常量引用的对象、字面值来初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> val = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = val;<br><span class="hljs-comment">//实际上发生</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = val; <span class="hljs-comment">//引用类型的临时量接受原类型的转换值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = temp; <span class="hljs-comment">//对临时量进行常量引用</span><br></code></pre></td></tr></table></figure><p><strong>举个栗子</strong><br>常量引用相当于给自己强制加了不可更改的道德准则，对于任何其他道德准则它都可以进行综合阉割并接收，即初始化。<br>其他人可以复印它的道德准则，因为这样没有更改原件的风险，即普通变量接收常量。<br>但是其他人要它的原件，它的道德准则就有被其他人修改的风险，即普通引用接收常量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref1 = i; <span class="hljs-comment">// 正确，i没道德无所谓，ref1有就行</span><br>    <span class="hljs-type">int</span> k = ref1;        <span class="hljs-comment">// 正确，k只复印ref1的准则</span><br>    <span class="hljs-type">int</span> &amp;m = ref1;       <span class="hljs-comment">// 错误，m要ref1的准则原件</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>指针和 <code>const</code><br>指向常量的指针（存放常量对象的地址），称为底层 <code>const</code>（解引用的对象不可修改）<br><code>const</code>指针（指针变量的值不能改变），称为顶层<code>const</code>（指针本身不可修改）</p><p><em>指向常量的指针或者引用，仅仅规定不能通过指针或者引用来改变对象，但对象到底能不能改变不由他俩决定，也就是上述例子说的它们只在乎自己的道德准则</em></p></li></ul><p><strong>处理类型</strong></p><ol><li><p>类型别名<br>关键字：typedef<br><code>typedef double wages, *p;</code>，wages 是 double 的同义词，p 是 <code>double*</code>的同义词<br>别名声明：using<br><code>using SI = Sales_item;</code>，SI 是 Sales_item 的同义词</p></li><li><p>指代复合类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>* pstring;<br><span class="hljs-type">const</span> pstring p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">//p是指向char的常量指针（把pstring看成基本类型，顶层const，p不可变）</span><br><span class="hljs-comment">//还原为const char *p = nullptr; 认为是底层const是错误的</span><br></code></pre></td></tr></table></figure><p><em>当复合类型使用了别名，使用别名时就相当于在使用基本类型</em></p></li><li><p>auto 类型说明符<br>作用：对于事先不知道的数据类型，auto 让编译器通过初始值来推算变量的类型。</p></li><li><p><code>decltype</code>类型指示符<br><code>decltype(func()) sum = 100;</code>，sum 的类型就是<code>func()</code>的返回值类型。</p></li><li><p>编写头文件<br>类通常被定义在头文件中，文件名与类名一致<br>预处理器（编译之前的一段程序）技术可以解决头文件多次包含的问题</p><ul><li><p>预处理功能#include<br>预处理器看到#include 标记时，会用指定的头文件内容替代#include</p></li><li><p>头文件保护符<br>#define 指令设定预处理变量，<code>#ifdef</code>和<code>#ifndef</code>检查预处理变量是否定义，直到<code>#endif</code>指令结束<br><strong>建议使用防卫式声明</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __HEAD_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HEAD_H__</span><br><br>...<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
