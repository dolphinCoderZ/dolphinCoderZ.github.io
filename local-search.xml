<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>调整数组顺序</title>
    <link href="/2023/11/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F/"/>
    <url>/2023/11/26/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="调整数组顺序使得奇数在前偶数在后"><a href="#调整数组顺序使得奇数在前偶数在后" class="headerlink" title="调整数组顺序使得奇数在前偶数在后"></a>调整数组顺序使得奇数在前偶数在后</h3><h6 id="输入一个整数数组，实现一个函数使得数组中的所有奇数位于前半部分，所有偶数位于后半部分。"><a href="#输入一个整数数组，实现一个函数使得数组中的所有奇数位于前半部分，所有偶数位于后半部分。" class="headerlink" title="输入一个整数数组，实现一个函数使得数组中的所有奇数位于前半部分，所有偶数位于后半部分。"></a>输入一个整数数组，实现一个函数使得数组中的所有奇数位于前半部分，所有偶数位于后半部分。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>一前一后双指针</p><ul><li><p>前指针找到一个偶数</p></li><li><p>后指针找到一个奇数</p></li><li><p>交换两者位置</p></li><li><p>直到两指针相遇</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeEven</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> length, <span class="hljs-type">bool</span> (*isEven)(<span class="hljs-type">int</span>))</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> end = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (begin &lt; end)<br>    &#123;<br>        <span class="hljs-comment">// 如果是偶数，则继续向前寻找，直到找到一个奇数</span><br>        <span class="hljs-keyword">while</span> (begin &lt; end &amp;&amp; <span class="hljs-built_in">isEven</span>(arr[end]) == <span class="hljs-literal">true</span>)<br>        &#123;<br>            end--;<br>        &#125;<br>        <span class="hljs-comment">// 如果是奇数，则继续向后寻找，直到找到一个偶数</span><br>        <span class="hljs-keyword">while</span> (begin &lt; end &amp;&amp; <span class="hljs-built_in">isEven</span>(arr[begin]) == <span class="hljs-literal">false</span>)<br>        &#123;<br>            begin++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (begin &lt; end)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(arr[begin], arr[end]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表中重复元素</title>
    <link href="/2023/11/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2023/11/25/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="删除链表中的重复元素"><a href="#删除链表中的重复元素" class="headerlink" title="删除链表中的重复元素"></a>删除链表中的重复元素</h3><h6 id="在一个排序的链表中，删除重复节点，重复的节点一个都不保留。"><a href="#在一个排序的链表中，删除重复节点，重复的节点一个都不保留。" class="headerlink" title="在一个排序的链表中，删除重复节点，重复的节点一个都不保留。"></a>在一个排序的链表中，删除重复节点，重复的节点一个都不保留。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>从头开始遍历链表</p><ul><li><p>如果当前节点与后一节点出现重复现象，那么需要进行删除操作。</p><ul><li>用临时指针从开始重复的节点开始遍历，边遍历边删除，直到出现第一个不重复的节点。</li></ul></li><li><p>为了不断开链表的连接，需要保留当前节点的前一节点指针。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteDuplicate</span><span class="hljs-params">(ListNode *&amp;head)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode *pre = <span class="hljs-literal">nullptr</span>;<br>    ListNode *cur = head;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        ListNode *pNext = cur-&gt;next;<br>        <span class="hljs-comment">// 出现重复现象</span><br>        <span class="hljs-keyword">if</span> (pNext &amp;&amp; pNext-&gt;m_data == cur-&gt;m_data)<br>        &#123;<br>            <span class="hljs-type">int</span> data = cur-&gt;m_data;<br>            <span class="hljs-comment">// q遍历每一个重复的节点并删除</span><br>            ListNode *q = cur;<br>            <span class="hljs-keyword">while</span> (q &amp;&amp; q-&gt;m_data == data)<br>            &#123;<br>                pNext = q-&gt;next;<br>                <span class="hljs-keyword">delete</span> q;<br>                q = <span class="hljs-literal">nullptr</span>;<br>                q = pNext;<br>            &#125;<br>            <span class="hljs-comment">// 退出循环时，q指向和前面节点不重复的第一个节点</span><br>            <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                head = q;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                pre-&gt;next = q;<br>            &#125;<br>            cur = q;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pre = cur;<br>            cur = pNext;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表指定节点</title>
    <link href="/2023/11/24/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9/"/>
    <url>/2023/11/24/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="删除链表中的指定节点"><a href="#删除链表中的指定节点" class="headerlink" title="删除链表中的指定节点"></a>删除链表中的指定节点</h3><h6 id="给定一个单链表的头指针和一个节点指针，定义一个函数在O-1-时间内删除该节点。节点定义如下："><a href="#给定一个单链表的头指针和一个节点指针，定义一个函数在O-1-时间内删除该节点。节点定义如下：" class="headerlink" title="给定一个单链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。节点定义如下："></a>给定一个单链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。节点定义如下：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    ListNode *next;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>删除节点需要有被删除节点的前一节点的指针，这样才能让链表重新接起来。</p><p>但找到被删除节点的前一节点指针需要顺序查找，直到某个节点的next等于被删除节点。</p><ul><li><p>题目要求O(1)时间</p></li><li><p>换一个思路，有了被删除节点的指针，就能找到后一个节点。</p></li><li><p>我们把后一个节点p的值赋值到被删除节点进行覆盖，然后删除p，效果也相当于删除了当前需要删除的节点。</p></li><li><p>特殊情况：如果需要删除的节点是尾节点，则仍然需要从头查找，然后删除。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode *&amp;head, ListNode *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 被删除节点不是尾节点</span><br>    <span class="hljs-keyword">if</span> (p-&gt;next)<br>    &#123;<br>        ListNode *pDelete = p-&gt;next;<br>        p-&gt;m_data = pDelete-&gt;m_data;<br>        p-&gt;next = pDelete-&gt;next;<br>        <span class="hljs-keyword">delete</span> pDelete;<br>        pDelete = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head == p)<span class="hljs-comment">// 链表只有一个节点</span><br>    &#123;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = <span class="hljs-literal">nullptr</span>;<br>        head = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ListNode *q = head;<br>        <span class="hljs-keyword">while</span> (q-&gt;next != p)<br>        &#123;<br>            q = q-&gt;next;<br>        &#125;<br>        q-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打印大数</title>
    <link href="/2023/11/22/%E6%89%93%E5%8D%B0%E5%A4%A7%E6%95%B0/"/>
    <url>/2023/11/22/%E6%89%93%E5%8D%B0%E5%A4%A7%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h3><h6 id="输入数字n，按顺序打印出从1到最大的n位十进制数，由于n可能会很大，请用字符串形式打印。"><a href="#输入数字n，按顺序打印出从1到最大的n位十进制数，由于n可能会很大，请用字符串形式打印。" class="headerlink" title="输入数字n，按顺序打印出从1到最大的n位十进制数，由于n可能会很大，请用字符串形式打印。"></a>输入数字n，按顺序打印出从1到最大的n位十进制数，由于n可能会很大，请用字符串形式打印。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printBigDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> *number = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(number, <span class="hljs-string">&#x27;0&#x27;</span>, n);<br>    number[n] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 没溢出</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">addNum</span>(number) == <span class="hljs-literal">false</span>)<br>    &#123;<br>        <span class="hljs-built_in">printNum</span>(number);<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] number;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">char</span> *number)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> isOverFlow = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> upDigit = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(number);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-type">int</span> count = number[i] + <span class="hljs-string">&#x27;0&#x27;</span> + upDigit;<br>        <span class="hljs-comment">// 每次都从最后一位+1</span><br>        <span class="hljs-keyword">if</span> (i == len - <span class="hljs-number">1</span>)<br>        &#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-comment">// 第一位还要进位，比如n位3，最大999，首位进位需要为4，溢出</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>            &#123;<br>                isOverFlow = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 可发生进位</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 计数清零</span><br>                count = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// 向上进位，当前位变为0</span><br>                number[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                upDigit = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            number[i] = count + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">char</span> *number)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> isBeginWith0 = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(number);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-comment">// 默认0打头</span><br>        <span class="hljs-keyword">if</span> (isBeginWith0)<br>        &#123;<br>            <span class="hljs-comment">// 找到第一个不是0的字符</span><br>            <span class="hljs-keyword">if</span> (number[i] != <span class="hljs-string">&#x27;0&#x27;</span>)<br>            &#123;<br>                isBeginWith0 = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isBeginWith0 == <span class="hljs-literal">false</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, number[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>以上代码其实就是用字符串模拟了整数的加法运算</p></blockquote><h6 id="此题还有一个思路：全排列"><a href="#此题还有一个思路：全排列" class="headerlink" title="此题还有一个思路：全排列"></a>此题还有一个思路：全排列</h6><blockquote><p>加入输入的n位3，即打印0，1，2，3…999</p><p>如果进行全排列，每一位顺序从0-9选出一个数，当第一位确定数字后，设置下一位，直到设置的位数超过n</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNumRecursive</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">char</span> *number = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n + <span class="hljs-number">1</span>];<br>    number[n] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-type">int</span> maxIndex = n - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        number[<span class="hljs-number">0</span>] = i + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-comment">// 设置下一位</span><br>        <span class="hljs-built_in">recursiveCore</span>(number, maxIndex, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursiveCore</span><span class="hljs-params">(<span class="hljs-type">char</span> *number, <span class="hljs-type">int</span> maxIndex, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 当前设置的下标超出数字的位数下标</span><br>    <span class="hljs-keyword">if</span> (index == maxIndex + <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printNum</span>(number);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        number[index] = i + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-built_in">recursiveCore</span>(number, maxIndex, index + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剪绳子</title>
    <link href="/2023/11/20/%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <url>/2023/11/20/%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h3><h6 id="给你一根长度为n的绳子，请把绳子剪成m段（m、n都为整数），每段绳子的长度记为k-0-、k-1-…k-m-。问k-0-k-1-k-2-…k-m-的最大乘积是多少。"><a href="#给你一根长度为n的绳子，请把绳子剪成m段（m、n都为整数），每段绳子的长度记为k-0-、k-1-…k-m-。问k-0-k-1-k-2-…k-m-的最大乘积是多少。" class="headerlink" title="给你一根长度为n的绳子，请把绳子剪成m段（m、n都为整数），每段绳子的长度记为k[0]、k[1]…k[m]。问k[0]k[1]k[2]…k[m]的最大乘积是多少。"></a>给你一根长度为n的绳子，请把绳子剪成m段（m、n都为整数），每段绳子的长度记为k[0]、k[1]…k[m]。问k[0]k[1]k[2]…k[m]的最大乘积是多少。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>长度为n的绳子，切第一刀有n-1中选择，切出来的绳子可能的长度为1，2，3，4，n-1。</p><p>记f(n)是最大得到乘积，那么f(n) &#x3D; max(f(i)×f(n-i))。</p><ul><li><p>首先考虑长度为1时，切不了，最大乘积就为1。</p></li><li><p>长度为2时，只能切成1和1，最大乘积为1。</p></li><li><p>长度为3时，可以切成1，1，1和1，2，最大乘积为2.</p></li><li><p>长度为4时</p><ul><li>可以切成（1，3），（2，2），（3，1），最大f(4) &#x3D; max(f(i)×f(n-i))，i &#x3D; 1，2，3</li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProductRope</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不能切</span><br>    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 当长度大于等于4时</span><br>    <span class="hljs-type">int</span> *products = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[length + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 不切就是n*0</span><br>    products[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 切一个1，就是n-1*1</span><br>    products[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 切一个2，就是n-2*2</span><br>    products[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 切一个3，就是n-3*3</span><br>    products[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= length; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// j初始化为1表示至少切一刀，切到一半，因为后面都是重复运算</span><br>        <span class="hljs-comment">// 例如7，（1，6）、（2，5）、（3，4），再往下（4，3）就开始重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; i &lt;= i / <span class="hljs-number">2</span>; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> temp = products[i] * products[i - j];<br>            <span class="hljs-keyword">if</span> (max &lt; temp)<br>            &#123;<br>                max = temp;<br>            &#125;<br>        &#125;<br>        products[i] = max;<br>    &#125;<br>    result = products[length];<br>    <span class="hljs-keyword">delete</span>[] products;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="/2023/11/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2023/11/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h3><h6 id="地上有一个m行n列的方格。一个机器人从坐标（0，0）的各自开始移动，它每次可以向左右上下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。请问机器人可以到达多少个格子。"><a href="#地上有一个m行n列的方格。一个机器人从坐标（0，0）的各自开始移动，它每次可以向左右上下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。请问机器人可以到达多少个格子。" class="headerlink" title="地上有一个m行n列的方格。一个机器人从坐标（0，0）的各自开始移动，它每次可以向左右上下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。请问机器人可以到达多少个格子。"></a>地上有一个m行n列的方格。一个机器人从坐标（0，0）的各自开始移动，它每次可以向左右上下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。请问机器人可以到达多少个格子。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>方格可以看成m行n列的矩阵。机器人从（0，0）开始移动，当他准备进入（i，j）格子时，判断检查条件。</p><ul><li><p>符合条件，则进入。接着判断上下左右相邻的格子是否可以进入。</p></li><li><p>不符合条件，则不能进入，返回到上一个格子判断其他相邻位置。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        res += num % <span class="hljs-number">10</span>;<br>        num /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> posRow, <span class="hljs-type">int</span> posCol, <span class="hljs-type">bool</span> *visited)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 未达边界，未走过，且坐标满足题设条件</span><br>    <span class="hljs-keyword">if</span> (posRow &gt;= <span class="hljs-number">0</span> &amp;&amp; posRow &lt; rows &amp;&amp; posCol &gt;= <span class="hljs-number">0</span> &amp;&amp; posCol &lt; cols &amp;&amp; visited[posRow * cols + posCol] == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-built_in">getSum</span>(posRow) + <span class="hljs-built_in">getSum</span>(posCol) &lt;= threshold)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 标志每个格子是否走过</span><br>    <span class="hljs-type">bool</span> *visited = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[rows * cols];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows * cols; i++)<br>    &#123;<br>        visited[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> count = <span class="hljs-built_in">movingCore</span>(threshold, rows, cols, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, visited);<br><br>    <span class="hljs-keyword">delete</span>[] visited;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCore</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> posRow, <span class="hljs-type">int</span> posCol, <span class="hljs-type">bool</span> *visited)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(threshold, rows, cols, posRow, posCol, visited))<br>    &#123;<br>        <span class="hljs-comment">// 将当前格子标志设置为true，表明已经走过当前格子</span><br>        visited[posRow * cols + posCol] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 考察当前格子的上下左右是否可以到达</span><br>        count = <span class="hljs-number">1</span> + <span class="hljs-built_in">movingCore</span>(threshold, rows, cols, posRow - <span class="hljs-number">1</span>, posCol, visited) <br>        + <span class="hljs-built_in">movingCore</span>(threshold, rows, cols, posRow, posCol - <span class="hljs-number">1</span>, visited)<br>        + <span class="hljs-built_in">movingCore</span>(threshold, rows, cols, posRow + <span class="hljs-number">1</span>, posCol, visited)<br>        + <span class="hljs-built_in">movingCore</span>(threshold, rows, cols, posRow, posCol + <span class="hljs-number">1</span>, visited);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="/2023/11/18/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <url>/2023/11/18/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><h6 id="把一个有序递增数组（无重复元素）的前若干元素搬到末尾称之为旋转数组，从旋转数组中找出整个数组的最小值。时间效率为O-logn"><a href="#把一个有序递增数组（无重复元素）的前若干元素搬到末尾称之为旋转数组，从旋转数组中找出整个数组的最小值。时间效率为O-logn" class="headerlink" title="把一个有序递增数组（无重复元素）的前若干元素搬到末尾称之为旋转数组，从旋转数组中找出整个数组的最小值。时间效率为O(logn)"></a>把一个有序递增数组（无重复元素）的前若干元素搬到末尾称之为旋转数组，从旋转数组中找出整个数组的最小值。时间效率为O(logn)</h6><blockquote><p>通常来说，遍历一遍数字即可获得最小值，但时间效率为O(n)</p><p>注意到，题目给出的旋转数组是有序数字变化而来，且要求时间效率为O(logn)</p><ul><li><p>考虑二分法（p头指针，q尾指针）</p></li><li><p>找出中间位置数字</p><ul><li><p>如果该数字位于前面的递增数组，则数组的最小数字应该在此数字后面，p改变到当前位置，缩小查找范围。</p></li><li><p>如果该数字位于后面的递增数组，则数组的最小数字应该在此数字前面，q改变到当前位置，缩小查找范围。</p></li><li><p>当p、q指向相邻的两个数组，此时p肯定指向了前面递增数组的最大值，而q指向了后面数组的最小值，也是整个数组的最小值。</p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (arr[low] &gt; arr[high])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (high - low == <span class="hljs-number">1</span>)<br>        &#123;<br>            mid = low;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[low])<br>        &#123;<br>            low = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; arr[high])<br>        &#123;<br>            mid = high;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[mid];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>员工年龄排序</title>
    <link href="/2023/11/17/%E5%91%98%E5%B7%A5%E5%B9%B4%E9%BE%84%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/11/17/%E5%91%98%E5%B7%A5%E5%B9%B4%E9%BE%84%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="员工年龄排序"><a href="#员工年龄排序" class="headerlink" title="员工年龄排序"></a>员工年龄排序</h3><h6 id="对公司所有员工（几万人）进行排序，年龄在0-99岁，要求时间效率为O-n-，辅助空间不得超过O-n"><a href="#对公司所有员工（几万人）进行排序，年龄在0-99岁，要求时间效率为O-n-，辅助空间不得超过O-n" class="headerlink" title="对公司所有员工（几万人）进行排序，年龄在0-99岁，要求时间效率为O(n)，辅助空间不得超过O(n)"></a>对公司所有员工（几万人）进行排序，年龄在0-99岁，要求时间效率为O(n)，辅助空间不得超过O(n)</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>题目中年龄在0-99岁，也就是说排序区间是0-99</p><p>员工有几万人，也就是说可能有很多个人具有相同的年龄。</p><p>可以对每个年龄进行计数，然后按照0-99的顺序进行排序，如果年龄出现多次则依次排序不分先后。</p><p>相当于有几万个数字，这些数字范围在0-99，对这些数字进行排序。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">srotAge</span><span class="hljs-params">(<span class="hljs-type">int</span> ages[], <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (ages == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> minAge = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> maxAge = <span class="hljs-number">99</span>;<br>    <span class="hljs-type">int</span> timesOfAge[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= maxAge; i++)<br>    &#123;<br>        timesOfAge[i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计每个年龄出现的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        timesOfAge[ages[i]]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 0-99进行排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= maxAge; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; timesOfAge[i]; j++)<br>        &#123;<br>            ages[index] = i;<br>            index++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2023/11/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/11/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>快速排序采用分治的思想，从部分有序到整体有序。</p><ul><li><p>从一个无序数组中取出第一个数字arr[0]</p></li><li><p>p指向arr[1]，q指向arr[n-1]</p></li><li><p>从q寻找到一个比arr[0]小的元素，交换p、q所指数字，使得小的数字整体位于前半部分；从p寻找到一个比arr[0]大的元素，交换p、q所指数字，使得大的数字整体位于后半部分。</p></li><li><p>当p和q相遇，则arr[0]暂时放入相遇的位置pos，此时该位置前面的数字都小于arr[0]，该位置后面的元素都大于arr[0]。</p></li><li><p>然后按照同样的逻辑在[p，pos-1]之间以及[pos+1，n-1]之间进行排序。</p></li><li><p>直到区间长度为1，此时所有的数字都满足该数字之前都小于该数字，该数字之后都大于该数字，从而使得整体有序。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[left];<br>    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot)<br>    &#123;<br>        right--;<br>    &#125;<br>    <span class="hljs-comment">// 小的移到前半部分</span><br>    arr[left] = arr[right];<br>    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt; pivot)<br>    &#123;<br>        left++;<br>    &#125;<br>    <span class="hljs-comment">// 大的移到后半部分</span><br>    arr[right] = arr[left];<br>    <span class="hljs-comment">// 相遇位置放枢轴</span><br>    arr[left] = pivot;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high)<br>    &#123;<br>        <span class="hljs-comment">// 相遇位置</span><br>        <span class="hljs-type">int</span> pos = <span class="hljs-built_in">partition</span>(arr, low, high);<br>        <span class="hljs-comment">// 相同逻辑排左边</span><br>        <span class="hljs-built_in">sort</span>(arr, low, pos - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 相同逻辑排右边</span><br>        <span class="hljs-built_in">sort</span>(arr, pos + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right)<br>    &#123;<br>        <span class="hljs-type">int</span> low = left;<br>        <span class="hljs-type">int</span> high = right;<br>        <span class="hljs-comment">// 枢轴</span><br>        <span class="hljs-type">int</span> pivot = arr[left];<br><br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt; pivot)<br>        &#123;<br>            high--;<br>        &#125;<br>        <span class="hljs-comment">// 小的移到前半部分</span><br>        arr[low] = arr[high];<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt; pivot)<br>        &#123;<br>            low++;<br>        &#125;<br>        <span class="hljs-comment">// 大的移到后半部分</span><br>        arr[high] = arr[low];<br>        <span class="hljs-comment">// 相遇位置放枢轴</span><br>        arr[low] = pivot;<br>        <span class="hljs-built_in">quickSort</span>(arr, left, low - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, low + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青蛙跳台阶</title>
    <link href="/2023/11/15/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <url>/2023/11/15/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h3><h6 id="一只青蛙可以一次跳一级台阶，也可以一次跳两级台阶。求该青蛙跳上一个n级台阶总共有多少中跳法。"><a href="#一只青蛙可以一次跳一级台阶，也可以一次跳两级台阶。求该青蛙跳上一个n级台阶总共有多少中跳法。" class="headerlink" title="一只青蛙可以一次跳一级台阶，也可以一次跳两级台阶。求该青蛙跳上一个n级台阶总共有多少中跳法。"></a>一只青蛙可以一次跳一级台阶，也可以一次跳两级台阶。求该青蛙跳上一个n级台阶总共有多少中跳法。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><ul><li><p>青蛙跳上一级台阶，只有一种跳法（跳一级）</p></li><li><p>青蛙跳上二级台阶，有两种跳法（直接跳两级或者跳两次一级）</p></li><li><p>青蛙跳上n级台阶</p><ul><li><p>可以从n-1级台阶跳一级到n级</p></li><li><p>可以从n-2级台阶跳两级到n级</p></li></ul></li><li><p>跳上n级台阶的跳法就是跳上n-1级台阶和跳上n-2级台阶的跳法总和</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fragJump</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fragJump</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fragJump</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fragJumpLoop</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> preOne = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> preTwo = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)<br>    &#123;<br>        result = preOne + preTwo;<br>        preTwo = preOne;<br>        preOne = result;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个队列实现栈</title>
    <link href="/2023/11/13/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/2023/11/13/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="两个队列实现栈"><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h3><h6 id="用两个队列模拟栈的功能"><a href="#用两个队列模拟栈的功能" class="headerlink" title="用两个队列模拟栈的功能"></a>用两个队列模拟栈的功能</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>按照栈后进先出的特点，当元素进入一个队列，出队列的时候就必须将前面的元素放入另一个队列，将最后一个元素输出（最后一个元素就是最后进入的元素），这样才符合后进先出。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CStack</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CStack</span>(<span class="hljs-type">void</span>);<br>    ~<span class="hljs-built_in">CStack</span>(<span class="hljs-type">void</span>);<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CStackPush</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;data)</span></span>;<br>    <span class="hljs-function">T <span class="hljs-title">CStackPop</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    queue&lt;T&gt; q1;<br>    queue&lt;T&gt; q2;<br>    queue&lt;T&gt; *in;<br>    queue&lt;T&gt; *out;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> CStack&lt;T&gt;::<span class="hljs-built_in">CStackPush</span>(<span class="hljs-type">const</span> T &amp;elem)<br>&#123;<br>    in-&gt;<span class="hljs-built_in">push</span>(elem);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T CStack&lt;T&gt;::<span class="hljs-built_in">CStackPop</span>()<br>&#123;<br>    <span class="hljs-comment">// 将队列1中最后一个元素前面的元素移动到队列2</span><br>    <span class="hljs-keyword">while</span> (in-&gt;<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>    &#123;<br>        out-&gt;<span class="hljs-built_in">push</span>(in-&gt;<span class="hljs-built_in">front</span>());<br>        in-&gt;<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-comment">//最后一个元素出队列，也就是栈的最后一个元素先出栈</span><br>    T res = in-&gt;<span class="hljs-built_in">front</span>();<br>    in-&gt;<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-comment">// 此时交换队列1和2的角色</span><br>    <span class="hljs-built_in">swap</span>(in, out);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个栈实现队列</title>
    <link href="/2023/11/12/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2023/11/12/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><h6 id="用两个栈模拟一个队列"><a href="#用两个栈模拟一个队列" class="headerlink" title="用两个栈模拟一个队列"></a>用两个栈模拟一个队列</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>栈的特点：后进先出</p><p>队列的特点：先进先出</p><p>题目给出两个栈：一个栈压入元素后，出栈时先把元素重新压入另一个栈，则原本在后面的元素又变成了在前面的元素，此时再出栈，则满足队列的特点。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CQueue</span>(<span class="hljs-type">void</span>);<br>    ~<span class="hljs-built_in">CQueue</span>(<span class="hljs-type">void</span>);<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;node)</span></span>;<br>    <span class="hljs-function">T <span class="hljs-title">delteHead</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;T&gt; stack1;<br>    stack&lt;T&gt; stack2;<br>&#125;;<br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> CQueue&lt;T&gt;::<span class="hljs-built_in">appendTail</span>(<span class="hljs-type">const</span> T &amp;elem)<br>&#123;<br>    stack1.<span class="hljs-built_in">push</span>(elem);<br>&#125;<br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>T CQueue&lt;T&gt;::<span class="hljs-built_in">delteHead</span>()<br>&#123;<br>    <span class="hljs-comment">// 当栈2不为空时，不能将栈1的元素压入，必须等到前一批输入全部出栈，这样才符合先进先出</span><br>    <span class="hljs-keyword">if</span> (stack2.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (stack1.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            T data = stack1.<span class="hljs-built_in">top</span>();<br>            stack1.<span class="hljs-built_in">pop</span>();<br>            stack2.<span class="hljs-built_in">push</span>(data);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (stack2.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;empty&quot;</span>;<br>    &#125;<br><br>    T head = stack2.<span class="hljs-built_in">top</span>();<br>    stack2.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的下一个节点</title>
    <link href="/2023/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2023/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="找出二叉树的下一个节点"><a href="#找出二叉树的下一个节点" class="headerlink" title="找出二叉树的下一个节点"></a>找出二叉树的下一个节点</h3><h6 id="给定一颗二叉树喝其中的一个节点，如何找出中序遍历的下一个节点？树中除了有两个分别指向左右子节点的指针，还有一个指向父节点的针织。"><a href="#给定一颗二叉树喝其中的一个节点，如何找出中序遍历的下一个节点？树中除了有两个分别指向左右子节点的指针，还有一个指向父节点的针织。" class="headerlink" title="给定一颗二叉树喝其中的一个节点，如何找出中序遍历的下一个节点？树中除了有两个分别指向左右子节点的指针，还有一个指向父节点的针织。"></a>给定一颗二叉树喝其中的一个节点，如何找出中序遍历的下一个节点？树中除了有两个分别指向左右子节点的指针，还有一个指向父节点的针织。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryTreeNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    BinaryTreeNode *left;<br>    BinaryTreeNode *right;<br>    BinaryTreeNode *parent;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><ul><li><p>如果所给节点有右子树，则所给节点的下个节点就是它右子树的最左下节点，沿右子树的左节点指针一直向下寻找，直到为空。</p></li><li><p>如果所给节点没有右子树</p><ul><li><p>如果所给节点是它父节点的左子节点，则它的下一节点就是其父节点。</p></li><li><p>如果所给节点是它父节点的右子节点，则沿着父节点指针向上，直到找到一个节点是它父节点的左子节点，则所找到的节点就是所给节点的下一节点。</p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BinaryTreeNode *<span class="hljs-title">nextNode</span><span class="hljs-params">(BinaryTreeNode *node)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    BinaryTreeNode *pNext = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 右节点存在，则下一节点就是右子树的最左下节点</span><br>    <span class="hljs-keyword">if</span> (node-&gt;right)<br>    &#123;<br>        BinaryTreeNode *p = p-&gt;right;<br>        <span class="hljs-keyword">while</span> (p)<br>        &#123;<br>            p = p-&gt;left;<br>        &#125;<br>        pNext = p;<br>    &#125;<br>    <span class="hljs-comment">// 右节点不存在</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (node-&gt;parent)<br>        &#123;<br>            <span class="hljs-comment">// 所给节点是它父节点的左子节点，按照中序遍历，它的下一节点就是它的父节点</span><br>            <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left)<br>            &#123;<br>                pNext = node-&gt;parent;<br>            &#125;<br>            <span class="hljs-comment">// 所给节点是它父节点的右子节点</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                BinaryTreeNode *cur = node;<br>                BinaryTreeNode *pParent = node-&gt;parent;<br>                <span class="hljs-keyword">while</span> (pParent &amp;&amp; cur != pParent-&gt;left)<br>                &#123;<br>                    cur = pParent;<br>                    pParent = pParent-&gt;parent;<br>                &#125;<br>                <span class="hljs-comment">// 如果是因为pParent == nullptr跳出循环，则说明所给节点是整个中序遍历中的最后一个节点，它的下一个节点为空</span><br>                <span class="hljs-comment">// 如果是因为cur == pParent-&gt;left跳出循环，则说明所给节点的位于左子树，它的下一节点是其某个祖先</span><br>                pNext = pParent;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pNext;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重建二叉树</title>
    <link href="/2023/11/09/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/11/09/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><h6 id="输入某二叉树的前序遍历和中序遍历结果，请重建这颗二叉树。加入输入的前序遍历和中序遍历结果中都不含重复的数字。二叉树节点的定义如下："><a href="#输入某二叉树的前序遍历和中序遍历结果，请重建这颗二叉树。加入输入的前序遍历和中序遍历结果中都不含重复的数字。二叉树节点的定义如下：" class="headerlink" title="输入某二叉树的前序遍历和中序遍历结果，请重建这颗二叉树。加入输入的前序遍历和中序遍历结果中都不含重复的数字。二叉树节点的定义如下："></a>输入某二叉树的前序遍历和中序遍历结果，请重建这颗二叉树。加入输入的前序遍历和中序遍历结果中都不含重复的数字。二叉树节点的定义如下：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryTreeNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    BinaryTreeNode *left;<br>    BinaryTreeNode *right;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>对于前序遍历，第一个数字总是树的根节点。对于中序遍历，根节点在序列的中间，左子树在根节点的左边，右子树在根节点的右边。</p><ul><li><p>首先根据前序遍历确定根节点</p></li><li><p>从中序遍历中找出根节点，进而找到左、右子树的序列</p></li><li><p>再用同样的方法构建左子树和右子树</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BinaryTreeNode *<span class="hljs-title">construct</span><span class="hljs-params">(<span class="hljs-type">int</span> preorder[], <span class="hljs-type">int</span> inorder[], <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (preorder == <span class="hljs-literal">nullptr</span> || inorder == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">constructCore</span>(preorder, preorder + length - <span class="hljs-number">1</span>, inorder, inorder + length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function">BinaryTreeNode *<span class="hljs-title">constructCore</span><span class="hljs-params">(<span class="hljs-type">int</span> *beginPre, <span class="hljs-type">int</span> *endPre, <span class="hljs-type">int</span> *beginIn, <span class="hljs-type">int</span> *endIn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> rootData = *beginPre;<br>    BinaryTreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryTreeNode</span>();<br>    root-&gt;m_data = rootData;<br>    root-&gt;left = <span class="hljs-literal">nullptr</span>;<br>    root-&gt;right = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">if</span> (beginPre == endPre)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (beginIn == endIn &amp;&amp; *beginPre == *beginIn)<br>        &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">// 输入有误</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 在中序遍历中找根节点</span><br>    <span class="hljs-type">int</span> *rootInorder = beginIn;<br>    <span class="hljs-keyword">while</span> (rootInorder &lt;= endIn &amp;&amp; *rootInorder != rootData)<br>    &#123;<br>        rootInorder++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rootInorder == endIn &amp;&amp; *rootInorder != rootData)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> leftTreeLength = rootInorder - beginIn;<br>    <span class="hljs-type">int</span> *leftTreeEnd = beginPre + leftTreeLength;<br><br>    <span class="hljs-keyword">if</span> (leftTreeLength &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 存在左子树</span><br>    &#123;<br>        root-&gt;left = <span class="hljs-built_in">constructCore</span>(beginPre + <span class="hljs-number">1</span>, leftTreeEnd, beginIn, rootInorder - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (leftTreeLength &lt; endPre - beginPre) <span class="hljs-comment">// 存在右子树</span><br>    &#123;<br>        root-&gt;right = <span class="hljs-built_in">constructCore</span>(leftTreeEnd + <span class="hljs-number">1</span>, endPre, rootInorder + <span class="hljs-number">1</span>, endIn);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="/2023/11/04/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/11/04/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><h6 id="输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下："><a href="#输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：" class="headerlink" title="输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下："></a>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    ListNode *next;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>从尾到头打印链表中的值，也就是说最后一个节点的值要第一个输出，符合后进先出特征，可以借助栈结构来实现。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printReverse</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ListNode *p = head;<br>    stack&lt;ListNode *&gt; nodes;<br>    <span class="hljs-keyword">while</span> (p)<br>    &#123;<br>        nodes.<span class="hljs-built_in">push</span>(p);<br>        p = p-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!nodes.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        p = nodes.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, p-&gt;m_data);<br>        node.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递归本质上也是一个栈结构，也可以采用递归来实现。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printReverse</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-comment">// 判断是否已到表尾</span><br>        <span class="hljs-keyword">if</span> (head-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-built_in">printReverse</span>(head-&gt;next);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, head-&gt;m_data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="/2023/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="在二维数组中查找数字"><a href="#在二维数组中查找数字" class="headerlink" title="在二维数组中查找数字"></a>在二维数组中查找数字</h3><h6 id="在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。"><a href="#在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。" class="headerlink" title="在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。"></a>在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>思路一：</p><p>从最右上角的数字num开始</p><ul><li><p>如果寻找的数字小于num，则继续在num所在列的左边寻找</p></li><li><p>如果寻找的数字大于num，则继续在num所在行的下面寻找</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNum</span><span class="hljs-params">(<span class="hljs-type">int</span> *matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (matrix != <span class="hljs-literal">nullptr</span> &amp;&amp; rows &gt; <span class="hljs-number">0</span> &amp;&amp; cols &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 定位最右上角元素</span><br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> col = cols - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (row &lt;= rows - <span class="hljs-number">1</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (num == matrix[row * cols + col])<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; matrix[row * cols + col])<br>            &#123;<br>                col--;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                row++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路二：</p><p>从最左下角数字num开始</p><ul><li><p>如果寻找的数字大于num，则继续在num所在列的右边寻找</p></li><li><p>如果寻找的数字小于num，则继续在num所在行的上方寻找</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNum</span><span class="hljs-params">(<span class="hljs-type">int</span> *matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (matrix != <span class="hljs-literal">nullptr</span> &amp;&amp; rows &gt; <span class="hljs-number">0</span> &amp;&amp; cols &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 定位最左下角元素</span><br>        <span class="hljs-type">int</span> row = rows - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt;= cols - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (num == matrix[row * cols + col])<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; matrix[row * cols + col])<br>            &#123;<br>                col++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                row--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>替换字符串中的空格</title>
    <link href="/2023/11/02/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/"/>
    <url>/2023/11/02/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="替换字符串中的空格"><a href="#替换字符串中的空格" class="headerlink" title="替换字符串中的空格"></a>替换字符串中的空格</h3><h6 id="请实现一个函数，把字符串中的每个空格替换成”-20”-例如，输入“We-are-happy”，则输出“We-20are-20happy”。"><a href="#请实现一个函数，把字符串中的每个空格替换成”-20”-例如，输入“We-are-happy”，则输出“We-20are-20happy”。" class="headerlink" title="请实现一个函数，把字符串中的每个空格替换成”%20”.例如，输入“We are happy”，则输出“We%20are%20happy”。"></a>请实现一个函数，把字符串中的每个空格替换成”%20”.例如，输入“We are happy”，则输出“We%20are%20happy”。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>将空格替换成”%20”一定会导致字符串变长，且空格后面的字符串一定会向后移动</p><ul><li><p>统计空格的个数</p></li><li><p>计算替换空格后新字符串的长度</p></li><li><p>两个指针，一个指针p指向原始字符串的结尾，另一个指针q指向新字符串的结尾</p></li><li><p>p从后往前扫描字符串</p><ul><li><p>如果没遇到空格，则将string[q] &#x3D; string[p]，两指针同时向前移动一位</p></li><li><p>遇到空格，sring[q] &#x3D; ‘0’，string[q-1] &#x3D; ‘2’，string[q-2] &#x3D; ‘%’，p移动一位，q移动三位</p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// length为字符数组的总容量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">replaceBlank</span><span class="hljs-params">(<span class="hljs-type">char</span> string[], <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> originalLen = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> blankNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (string[i] != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#123;<br>        originalLen++;<br>        <span class="hljs-keyword">if</span> (string[i] == <span class="hljs-string">&#x27; &#x27;</span>)<br>        &#123;<br>            blankNum++;<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-type">int</span> newLen = originalLen + <span class="hljs-number">2</span> * blankNum;<br>    <span class="hljs-keyword">if</span> (newLen &gt; length)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> indexOfOringin = originalLen;<br>    <span class="hljs-type">int</span> indexOfNew = newLen;<br>    <span class="hljs-keyword">while</span> (indexOfOringin &gt;= <span class="hljs-number">0</span> &amp;&amp; indexOfOringin &lt; indexOfNew)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (string[indexOfOringin] == <span class="hljs-string">&#x27; &#x27;</span>)<br>        &#123;<br>            string[indexOfNew] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            string[indexOfNew - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            string[indexOfNew - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>            indexOfNew -= <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            string[indexOfNew] = string[indexOfOringin];<br>            indexOfNew -= <span class="hljs-number">1</span>;<br>        &#125;<br>        indexOfOringin--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中的重复数字</title>
    <link href="/2023/11/01/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/"/>
    <url>/2023/11/01/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h3><h6 id="在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。"><a href="#在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。" class="headerlink" title="在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。"></a>在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>从头到尾扫描数组array（循环），首先比较数字num和index是否相等。</p><ul><li><p>如果相等，则接着扫描下一个数字。</p></li><li><p>如果不相等，则将数字num和arr[num]比较</p><ul><li><p>如果num&#x3D;&#x3D;arr[num]，则num就是一个重复数字</p></li><li><p>如果num!&#x3D;arr[num]，则swap(num,arr[num])，将num放在属于它的位置，继续比较当前位置和交换后的数字（循环）</p></li></ul></li></ul></blockquote><p><strong>此方法修改了原始数组</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> *duplicate)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">nullptr</span> || len &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span> || nums[i] &gt; len - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;    <br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (nums[i] != i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[nums[i])<br>            &#123;<br>                *duplicate = nums[i];<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-type">int</span> temp = nums[i];<br>                nums[temp] = nums[i];<br>                nums[i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不修改数组找出重复的数字"><a href="#不修改数组找出重复的数字" class="headerlink" title="不修改数组找出重复的数字"></a>不修改数组找出重复的数字</h3><h6 id="在一个长为n-1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。"><a href="#在一个长为n-1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。" class="headerlink" title="在一个长为n+1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。"></a>在一个长为n+1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。</h6><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote><p>采用二分法</p><p>三个指针：low、mid、high</p><p>例如：{2，3，5，4，3，2，6，7}，统计整个数组中1-4和4-7的数字个数count</p><ul><li><p>如果count&gt;mid-low+1，则说明重复数字在[low，mid]范围，high &#x3D; mid</p></li><li><p>否则，重复数字在[mid，high]范围，low &#x3D; mid + 1</p></li></ul><p>直到low&#x3D;&#x3D;high</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> high = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (low &lt; high)<br>    &#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-built_in">countRange</span>(nums, length, low, high);<br>        <span class="hljs-keyword">if</span> (count &gt; mid - low + <span class="hljs-number">1</span>)<br>        &#123;<br>            high = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (low == high)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countRange</span>(nums, length, low, high) &gt; <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> low;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countRange</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> length, <span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt;= min &amp;&amp; nums[i] &lt;= max)<br>        &#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 变量与基本类型</title>
    <link href="/2023/10/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/10/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h3><p><strong>变量定义</strong><br>类型说明符 变量名 &#x3D; 初始值</p><blockquote><p>注意：初始化和赋值的区别<br>初始化：创建变量的时候赋予其一个初始值<br>赋值：把对象的当前值擦除，用新值来替代</p></blockquote><p><strong>初始化</strong></p><ol><li><p>列表初始化<br>例如：①int i &#x3D; 0; ②int i(0) ③int i{0}<br>② 如果用变量来初始化，可能会丢失精度，但可以初始化成功<br>③ 是 C++11 的特性，如果会丢失精度，编译器会报错，初始化失败</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-number">3.14</span>)</span></span>;<br>    cout &lt;&lt; i &lt;&lt; endl; <span class="hljs-comment">//3</span><br>    <span class="hljs-type">int</span> j&#123;<span class="hljs-number">3.14</span>&#125;; <span class="hljs-comment">//编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>默认初始化<br>定义在任何&#x3D;&#x3D;函数体之外&#x3D;&#x3D;的变量被初始化为 0<br>定义在&#x3D;&#x3D;函数体内部的内置类型变量&#x3D;&#x3D;将不被初始化（依据书中，但不同编译器做法不同）<br>类可以自主决定初始化对象的方式（构造）<br><em>建议初始化每一个内置类型的变量</em></p></li></ol><p><strong>声明与定义</strong><br>声明：规定变量的类型和名，不会默认初始化，而是未定义<br>定义：除声明所做事情之外，还会创建与名字关联的实体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;       <span class="hljs-comment">//声明</span><br><span class="hljs-type">int</span> j;              <span class="hljs-comment">//定义</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;   <span class="hljs-comment">//定义（显示初始化的声明会成为定义，函数体内部不能用）</span><br></code></pre></td></tr></table></figure><p><em>变量只能被定义一次，但可以声明多次（定义出现在某一个文件中，其他文件只能对其进行声明）</em></p><p><strong>引用和指针</strong></p><ul><li><p>引用<br>引用始终和它的初始值（只能是对象）绑定在一起（之后无法改变），因此 <em>定义引用的时候必须初始化且不能是例如字面值之类的非对象初始值</em></p><p>操作引用实际上就是在操作与之绑定的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> &amp;ref1;        <span class="hljs-comment">//错误，未初始化</span><br>    <span class="hljs-type">int</span> &amp;ref2 = <span class="hljs-number">1024</span>; <span class="hljs-comment">//错误，绑定的不是对象，而是字面值</span><br><br>    <span class="hljs-type">int</span> value = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">int</span> &amp;ref3 = value;<br>    ref3 = <span class="hljs-number">2048</span>;<br>    cout &lt;&lt; value &lt;&lt; endl; <span class="hljs-comment">// 2048，引用就是被绑定对象的别名</span><br>    cout &lt;&lt; ref3 &lt;&lt; endl;  <span class="hljs-comment">// 2048</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;引用本身不是一个对象，因此不能定义引用的引用&#x3D;&#x3D;<br>引用类型要与初始化对象类型对应</p></blockquote></li><li><p>指针<br>指针保存对象的地址，同时指针本身也是一个对象，可以重复赋值，也可以被引用绑定<br>获取一个对象的地址使用<code>&amp;</code>，用对应类型的指针接收<br>有效的指针通过解引用<code>*p</code>来访问指向的对象</p><blockquote><p>空指针，<code>int *p = nullptr;</code><br>建议初始化所有指针，不然不知道指向了那一块内存，使用时可能会出现访存错误<br><code>void*</code>指针，只是单纯存放一个内存地址，由于不知道此地址存放的对象的类型，可以进行的操作有限</p></blockquote></li><li><p>对指针的引用<br><code>int *&amp;pi = p;</code><br>从右往左阅读，首先<code>&amp;pi</code> 是一个引用，对<code>int *</code>的引用，也就是对指针的引用</p></li></ul><p><strong><code>const</code> 限定符</strong></p><p>作用：不允许<code>const</code>修饰的对象重新赋值</p><ul><li><p>初始化<br><code>const</code>对象一旦创建后其值不能再改变，因此必须进行初始化<br>可以用其他对象对<code>const</code>对象进行初始化，也可以用 <code>const</code> 对象初始化其他对象（调用 operator&#x3D;）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> j = i; <span class="hljs-comment">// j的常量特性只在执行改变j时发挥作用</span><br>    <span class="hljs-type">int</span> k = j;       <span class="hljs-comment">//合理，k拷贝j的值并不会改变j</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>extern 的利用<br><code>const int buffSize = 512;</code>，<em>编译器在编译的时候将所有 <code>buffSize</code> 替换为 512</em><br><code>const </code>对象被设定为只在文件内有效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//file_1.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffSize = <span class="hljs-built_in">func</span>();       <span class="hljs-comment">//extern限定使常量能被其他文件所用</span><br><span class="hljs-comment">//file_1.h</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffSize;                <span class="hljs-comment">//在头文件表明const对象文件共享</span><br></code></pre></td></tr></table></figure><p><em>多个文件共享<code>const</code>对象需要在 <code>const</code> 对象的定义前加 extern</em></p></li><li><p>常量引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1024</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = a;<br></code></pre></td></tr></table></figure><p>引用的对象不可变，由于引用是别名（改变引用会改变绑定的对象），所以引用也不能变。</p></li><li><p>常量引用的初始化<br>与一般的引用不同，常量引用可以用非常量引用的对象、字面值来初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> val = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = val;<br><span class="hljs-comment">//实际上发生</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = val; <span class="hljs-comment">//引用类型的临时量接受原类型的转换值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = temp; <span class="hljs-comment">//对临时量进行常量引用</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;举个栗子&#x3D;&#x3D;<br>常量引用相当于给自己强制加了不可更改的道德准则，对于任何其他道德准则它都可以进行综合阉割并接收&#x3D;》对应于初始化<br>其他人可以复印它的道德准则，因为这样没有更改原件的风险&#x3D;》对应于普通变量接收常量<br>但是其他人要它的原件，它的道德准则就有被其他人修改的风险&#x3D;》对应于普通引用接收常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref1 = i; <span class="hljs-comment">// 正确，i没道德无所谓，ref1有就行</span><br>    <span class="hljs-type">int</span> k = ref1;        <span class="hljs-comment">// 正确，k只复印ref1的准则</span><br>    <span class="hljs-type">int</span> &amp;m = ref1;       <span class="hljs-comment">// 错误，m要ref1的准则原件</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>指针和 <code>const</code><br>指向常量的指针（存放常量对象的地址），称为底层 <code>const</code>（解引用的对象不可修改）<br><code>const </code>指针（指针变量的值不能改变），称为顶层<code> const</code>（指针本身不可修改）</p><p><em>指向常量的指针或者引用，仅仅规定不能通过指针或者引用来改变对象，但对象到底能不能改变不由他俩决定，也就是上述例子说的它们只在乎自己的道德准则</em></p></li></ul><p><strong>处理类型</strong></p><ol><li><p>类型别名<br>关键字：typedef<br><code>typedef double wages, *p;</code>，wages 是 double 的同义词，p 是 <code>double*</code>的同义词<br>别名声明：using<br><code>using SI = Sales_item;</code>，SI 是 Sales_item 的同义词</p></li><li><p>指代复合类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>* pstring;<br><span class="hljs-type">const</span> pstring p = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//p是指向char的常量指针（把pstring看成基本类型，顶层const，p不可变），还原为const char *p = nullptr;认识是底层const是错误的</span><br></code></pre></td></tr></table></figure><p><em>当复合类型使用了别名，使用别名时就相当于在使用基本类型</em></p></li><li><p>auto 类型说明符<br>作用：对于事先不知道的数据类型，auto 让编译器通过初始值来推算变量的类型</p></li><li><p><code>decltype </code>类型指示符<br><code>decltype(func()) sum = 100;</code>，sum 的类型就是<code> func()</code>的返回值类型</p></li><li><p>编写头文件<br>类通常被定义在头文件中，文件名与类名一致<br>预处理器（编译之前的一段程序）技术可以解决头文件多次包含的问题</p><ul><li><p>预处理功能#include<br>预处理器看到#include 标记时，会用指定的头文件内容替代#include</p></li><li><p>头文件保护符<br>#define 指令设定预处理变量，<code>#ifdef </code>和<code>#ifndef </code>检查预处理变量是否定义，直到<code>#endif </code>指令结束<br>建议使用防卫式声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __HEAD_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HEAD_H__</span><br><br>...<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 迭代器基础</title>
    <link href="/2023/10/24/%E7%AC%AC%E4%B8%89%E7%AB%A0_%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/10/24/%E7%AC%AC%E4%B8%89%E7%AB%A0_%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h3><p>行为类似于指针，迭代器也提供了对对象进行间接访问<br>所有标准库容器都支持迭代器，string 不属于容器但也支持迭代器</p><ul><li>使用迭代器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> start = v.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//第一个元素的迭代器</span><br><span class="hljs-keyword">auto</span> end = v.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//尾后迭代器（尾元素的下一个位置）</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;通过迭代器修改元素，效果与引用或指针一样&#x3D;&#x3D;<br>迭代器也可以通过递增操作实现访问下一元素，最多移动到尾后迭代器<br>迭代器判断使用<code>!=</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; endl; <span class="hljs-comment">//类似指针解引用，箭头运算符也可以使用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>迭代器类型<ol><li>iterator<br>可读可写</li><li><code>const_iterator</code>（类似于指针常量）<br>可读不可写</li><li><code>cbegin</code> 和 <code>cend</code><br>返回 <code>const_iterator</code> 类型<br>&#x3D;&#x3D;使用了迭代器的循环体，就不能再向迭代器所属的容器中添加元素，否则会导致迭代器失效&#x3D;&#x3D;</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
