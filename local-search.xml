<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>青蛙跳台阶</title>
    <link href="/2023/11/15/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <url>/2023/11/15/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个队列实现栈</title>
    <link href="/2023/11/13/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/2023/11/13/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个栈实现队列</title>
    <link href="/2023/11/12/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2023/11/12/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的下一个节点</title>
    <link href="/2023/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2023/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重建二叉树</title>
    <link href="/2023/11/09/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/11/09/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="/2023/11/04/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/11/04/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><h6 id="输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下："><a href="#输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：" class="headerlink" title="输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下："></a>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> m_data;<br>    ListNode *next;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>从尾到头打印链表中的值，也就是说最后一个节点的值要第一个输出，符合后进先出特征，可以借助栈结构来实现。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printReverse</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ListNode *p = head;<br>    stack&lt;ListNode *&gt; nodes;<br>    <span class="hljs-keyword">while</span> (p)<br>    &#123;<br>        nodes.<span class="hljs-built_in">push</span>(p);<br>        p = p-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!nodes.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        p = nodes.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, p-&gt;m_data);<br>        node.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递归本质上也是一个栈结构，也可以采用递归来实现。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printReverse</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-comment">// 判断是否已到表尾</span><br>        <span class="hljs-keyword">if</span> (head-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-built_in">printReverse</span>(head-&gt;next);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, head-&gt;m_data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="/2023/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/11/03/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="在二维数组中查找数字"><a href="#在二维数组中查找数字" class="headerlink" title="在二维数组中查找数字"></a>在二维数组中查找数字</h3><h6 id="在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。"><a href="#在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。" class="headerlink" title="在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。"></a>在一个二维数组中，每一行都按照从左到右递增排列，每一列都按照从上到下递增排列。请实现一个函数，在这样的数组中朝朝是否含有给出的在一个整数。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>思路一：</p><p>从最右上角的数字num开始</p><ul><li><p>如果寻找的数字小于num，则继续在num所在列的左边寻找</p></li><li><p>如果寻找的数字大于num，则继续在num所在行的下面寻找</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNum</span><span class="hljs-params">(<span class="hljs-type">int</span> *matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (matrix != <span class="hljs-literal">nullptr</span> &amp;&amp; rows &gt; <span class="hljs-number">0</span> &amp;&amp; cols &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 定位最右上角元素</span><br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> col = cols - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (row &lt;= rows - <span class="hljs-number">1</span> &amp;&amp; col &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (num == matrix[row * cols + col])<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; matrix[row * cols + col])<br>            &#123;<br>                col--;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                row++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思路二：</p><p>从最左下角数字num开始</p><ul><li><p>如果寻找的数字大于num，则继续在num所在列的右边寻找</p></li><li><p>如果寻找的数字小于num，则继续在num所在行的上方寻找</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNum</span><span class="hljs-params">(<span class="hljs-type">int</span> *matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (matrix != <span class="hljs-literal">nullptr</span> &amp;&amp; rows &gt; <span class="hljs-number">0</span> &amp;&amp; cols &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 定位最左下角元素</span><br>        <span class="hljs-type">int</span> row = rows - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt;= cols - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (num == matrix[row * cols + col])<br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; matrix[row * cols + col])<br>            &#123;<br>                col++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                row--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>替换字符串中的空格</title>
    <link href="/2023/11/02/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/"/>
    <url>/2023/11/02/%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="替换字符串中的空格"><a href="#替换字符串中的空格" class="headerlink" title="替换字符串中的空格"></a>替换字符串中的空格</h3><h6 id="请实现一个函数，把字符串中的每个空格替换成”-20”-例如，输入“We-are-happy”，则输出“We-20are-20happy”。"><a href="#请实现一个函数，把字符串中的每个空格替换成”-20”-例如，输入“We-are-happy”，则输出“We-20are-20happy”。" class="headerlink" title="请实现一个函数，把字符串中的每个空格替换成”%20”.例如，输入“We are happy”，则输出“We%20are%20happy”。"></a>请实现一个函数，把字符串中的每个空格替换成”%20”.例如，输入“We are happy”，则输出“We%20are%20happy”。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>将空格替换成”%20”一定会导致字符串变长，且空格后面的字符串一定会向后移动</p><ul><li><p>统计空格的个数</p></li><li><p>计算替换空格后新字符串的长度</p></li><li><p>两个指针，一个指针p指向原始字符串的结尾，另一个指针q指向新字符串的结尾</p></li><li><p>p从后往前扫描字符串</p><ul><li><p>如果没遇到空格，则将string[q] &#x3D; string[p]，两指针同时向前移动一位</p></li><li><p>遇到空格，sring[q] &#x3D; ‘0’，string[q-1] &#x3D; ‘2’，string[q-2] &#x3D; ‘%’，p移动一位，q移动三位</p></li></ul></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// length为字符数组的总容量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">replaceBlank</span><span class="hljs-params">(<span class="hljs-type">char</span> string[], <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> originalLen = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> blankNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (string[i] != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#123;<br>        originalLen++;<br>        <span class="hljs-keyword">if</span> (string[i] == <span class="hljs-string">&#x27; &#x27;</span>)<br>        &#123;<br>            blankNum++;<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-type">int</span> newLen = originalLen + <span class="hljs-number">2</span> * blankNum;<br>    <span class="hljs-keyword">if</span> (newLen &gt; length)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> indexOfOringin = originalLen;<br>    <span class="hljs-type">int</span> indexOfNew = newLen;<br>    <span class="hljs-keyword">while</span> (indexOfOringin &gt;= <span class="hljs-number">0</span> &amp;&amp; indexOfOringin &lt; indexOfNew)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (string[indexOfOringin] == <span class="hljs-string">&#x27; &#x27;</span>)<br>        &#123;<br>            string[indexOfNew] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            string[indexOfNew - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            string[indexOfNew - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>            indexOfNew -= <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            string[indexOfNew] = string[indexOfOringin];<br>            indexOfNew -= <span class="hljs-number">1</span>;<br>        &#125;<br>        indexOfOringin--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中的重复数字</title>
    <link href="/2023/11/01/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/"/>
    <url>/2023/11/01/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h3><h6 id="在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。"><a href="#在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。" class="headerlink" title="在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。"></a>在一个长度为n的数组里的所有数字都在0到n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</h6><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>从头到尾扫描数组array（循环），首先比较数字num和index是否相等。</p><ul><li><p>如果相等，则接着扫描下一个数字。</p></li><li><p>如果不相等，则将数字num和arr[num]比较</p><ul><li><p>如果num&#x3D;&#x3D;arr[num]，则num就是一个重复数字</p></li><li><p>如果num!&#x3D;arr[num]，则swap(num,arr[num])，将num放在属于它的位置，继续比较当前位置和交换后的数字（循环）</p></li></ul></li></ul></blockquote><p><strong>此方法修改了原始数组</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> *duplicate)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">nullptr</span> || len &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span> || nums[i] &gt; len - <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;    <br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (nums[i] != i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[nums[i])<br>            &#123;<br>                *duplicate = nums[i];<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-type">int</span> temp = nums[i];<br>                nums[temp] = nums[i];<br>                nums[i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不修改数组找出重复的数字"><a href="#不修改数组找出重复的数字" class="headerlink" title="不修改数组找出重复的数字"></a>不修改数组找出重复的数字</h3><h6 id="在一个长为n-1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。"><a href="#在一个长为n-1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。" class="headerlink" title="在一个长为n+1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。"></a>在一个长为n+1的数组里的所有数字都在1-n的范围内，所以数组中至少有一个数字重复。找出重复数字但不能修改原始数组。</h6><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote><p>采用二分法</p><p>三个指针：low、mid、high</p><p>例如：{2，3，5，4，3，2，6，7}，统计整个数组中1-4和4-7的数字个数count</p><ul><li><p>如果count&gt;mid-low+1，则说明重复数字在[low，mid]范围，high &#x3D; mid</p></li><li><p>否则，重复数字在[mid，high]范围，low &#x3D; mid + 1</p></li></ul><p>直到low&#x3D;&#x3D;high</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">nullptr</span> || length &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> high = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (low &lt; high)<br>    &#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-built_in">countRange</span>(nums, length, low, high);<br>        <span class="hljs-keyword">if</span> (count &gt; mid - low + <span class="hljs-number">1</span>)<br>        &#123;<br>            high = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (low == high)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countRange</span>(nums, length, low, high) &gt; <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> low;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countRange</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> length, <span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt;= min &amp;&amp; nums[i] &lt;= max)<br>        &#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 变量与基本类型</title>
    <link href="/2023/10/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/10/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h3><p><strong>变量定义</strong><br>类型说明符 变量名 &#x3D; 初始值</p><blockquote><p>注意：初始化和赋值的区别<br>初始化：创建变量的时候赋予其一个初始值<br>赋值：把对象的当前值擦除，用新值来替代</p></blockquote><p><strong>初始化</strong></p><ol><li><p>列表初始化<br>例如：①int i &#x3D; 0; ②int i(0) ③int i{0}<br>② 如果用变量来初始化，可能会丢失精度，但可以初始化成功<br>③ 是 C++11 的特性，如果会丢失精度，编译器会报错，初始化失败</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-number">3.14</span>)</span></span>;<br>    cout &lt;&lt; i &lt;&lt; endl; <span class="hljs-comment">//3</span><br>    <span class="hljs-type">int</span> j&#123;<span class="hljs-number">3.14</span>&#125;; <span class="hljs-comment">//编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>默认初始化<br>定义在任何&#x3D;&#x3D;函数体之外&#x3D;&#x3D;的变量被初始化为 0<br>定义在&#x3D;&#x3D;函数体内部的内置类型变量&#x3D;&#x3D;将不被初始化（依据书中，但不同编译器做法不同）<br>类可以自主决定初始化对象的方式（构造）<br><em>建议初始化每一个内置类型的变量</em></p></li></ol><p><strong>声明与定义</strong><br>声明：规定变量的类型和名，不会默认初始化，而是未定义<br>定义：除声明所做事情之外，还会创建与名字关联的实体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i;       <span class="hljs-comment">//声明</span><br><span class="hljs-type">int</span> j;              <span class="hljs-comment">//定义</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;   <span class="hljs-comment">//定义（显示初始化的声明会成为定义，函数体内部不能用）</span><br></code></pre></td></tr></table></figure><p><em>变量只能被定义一次，但可以声明多次（定义出现在某一个文件中，其他文件只能对其进行声明）</em></p><p><strong>引用和指针</strong></p><ul><li><p>引用<br>引用始终和它的初始值（只能是对象）绑定在一起（之后无法改变），因此 <em>定义引用的时候必须初始化且不能是例如字面值之类的非对象初始值</em></p><p>操作引用实际上就是在操作与之绑定的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> &amp;ref1;        <span class="hljs-comment">//错误，未初始化</span><br>    <span class="hljs-type">int</span> &amp;ref2 = <span class="hljs-number">1024</span>; <span class="hljs-comment">//错误，绑定的不是对象，而是字面值</span><br><br>    <span class="hljs-type">int</span> value = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">int</span> &amp;ref3 = value;<br>    ref3 = <span class="hljs-number">2048</span>;<br>    cout &lt;&lt; value &lt;&lt; endl; <span class="hljs-comment">// 2048，引用就是被绑定对象的别名</span><br>    cout &lt;&lt; ref3 &lt;&lt; endl;  <span class="hljs-comment">// 2048</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>&#x3D;&#x3D;引用本身不是一个对象，因此不能定义引用的引用&#x3D;&#x3D;<br>引用类型要与初始化对象类型对应</p></blockquote></li><li><p>指针<br>指针保存对象的地址，同时指针本身也是一个对象，可以重复赋值，也可以被引用绑定<br>获取一个对象的地址使用<code>&amp;</code>，用对应类型的指针接收<br>有效的指针通过解引用<code>*p</code>来访问指向的对象</p><blockquote><p>空指针，<code>int *p = nullptr;</code><br>建议初始化所有指针，不然不知道指向了那一块内存，使用时可能会出现访存错误<br><code>void*</code>指针，只是单纯存放一个内存地址，由于不知道此地址存放的对象的类型，可以进行的操作有限</p></blockquote></li><li><p>对指针的引用<br><code>int *&amp;pi = p;</code><br>从右往左阅读，首先<code>&amp;pi</code> 是一个引用，对<code>int *</code>的引用，也就是对指针的引用</p></li></ul><p><strong><code>const</code> 限定符</strong></p><p>作用：不允许<code>const</code>修饰的对象重新赋值</p><ul><li><p>初始化<br><code>const</code>对象一旦创建后其值不能再改变，因此必须进行初始化<br>可以用其他对象对<code>const</code>对象进行初始化，也可以用 <code>const</code> 对象初始化其他对象（调用 operator&#x3D;）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> j = i; <span class="hljs-comment">// j的常量特性只在执行改变j时发挥作用</span><br>    <span class="hljs-type">int</span> k = j;       <span class="hljs-comment">//合理，k拷贝j的值并不会改变j</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>extern 的利用<br><code>const int buffSize = 512;</code>，<em>编译器在编译的时候将所有 <code>buffSize</code> 替换为 512</em><br><code>const </code>对象被设定为只在文件内有效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//file_1.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffSize = <span class="hljs-built_in">func</span>();       <span class="hljs-comment">//extern限定使常量能被其他文件所用</span><br><span class="hljs-comment">//file_1.h</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffSize;                <span class="hljs-comment">//在头文件表明const对象文件共享</span><br></code></pre></td></tr></table></figure><p><em>多个文件共享<code>const</code>对象需要在 <code>const</code> 对象的定义前加 extern</em></p></li><li><p>常量引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1024</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = a;<br></code></pre></td></tr></table></figure><p>引用的对象不可变，由于引用是别名（改变引用会改变绑定的对象），所以引用也不能变。</p></li><li><p>常量引用的初始化<br>与一般的引用不同，常量引用可以用非常量引用的对象、字面值来初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> val = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = val;<br><span class="hljs-comment">//实际上发生</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = val; <span class="hljs-comment">//引用类型的临时量接受原类型的转换值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = temp; <span class="hljs-comment">//对临时量进行常量引用</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;举个栗子&#x3D;&#x3D;<br>常量引用相当于给自己强制加了不可更改的道德准则，对于任何其他道德准则它都可以进行综合阉割并接收&#x3D;》对应于初始化<br>其他人可以复印它的道德准则，因为这样没有更改原件的风险&#x3D;》对应于普通变量接收常量<br>但是其他人要它的原件，它的道德准则就有被其他人修改的风险&#x3D;》对应于普通引用接收常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref1 = i; <span class="hljs-comment">// 正确，i没道德无所谓，ref1有就行</span><br>    <span class="hljs-type">int</span> k = ref1;        <span class="hljs-comment">// 正确，k只复印ref1的准则</span><br>    <span class="hljs-type">int</span> &amp;m = ref1;       <span class="hljs-comment">// 错误，m要ref1的准则原件</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>指针和 <code>const</code><br>指向常量的指针（存放常量对象的地址），称为底层 <code>const</code>（解引用的对象不可修改）<br><code>const </code>指针（指针变量的值不能改变），称为顶层<code> const</code>（指针本身不可修改）</p><p><em>指向常量的指针或者引用，仅仅规定不能通过指针或者引用来改变对象，但对象到底能不能改变不由他俩决定，也就是上述例子说的它们只在乎自己的道德准则</em></p></li></ul><p><strong>处理类型</strong></p><ol><li><p>类型别名<br>关键字：typedef<br><code>typedef double wages, *p;</code>，wages 是 double 的同义词，p 是 <code>double*</code>的同义词<br>别名声明：using<br><code>using SI = Sales_item;</code>，SI 是 Sales_item 的同义词</p></li><li><p>指代复合类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>* pstring;<br><span class="hljs-type">const</span> pstring p = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//p是指向char的常量指针（把pstring看成基本类型，顶层const，p不可变），还原为const char *p = nullptr;认识是底层const是错误的</span><br></code></pre></td></tr></table></figure><p><em>当复合类型使用了别名，使用别名时就相当于在使用基本类型</em></p></li><li><p>auto 类型说明符<br>作用：对于事先不知道的数据类型，auto 让编译器通过初始值来推算变量的类型</p></li><li><p><code>decltype </code>类型指示符<br><code>decltype(func()) sum = 100;</code>，sum 的类型就是<code> func()</code>的返回值类型</p></li><li><p>编写头文件<br>类通常被定义在头文件中，文件名与类名一致<br>预处理器（编译之前的一段程序）技术可以解决头文件多次包含的问题</p><ul><li><p>预处理功能#include<br>预处理器看到#include 标记时，会用指定的头文件内容替代#include</p></li><li><p>头文件保护符<br>#define 指令设定预处理变量，<code>#ifdef </code>和<code>#ifndef </code>检查预处理变量是否定义，直到<code>#endif </code>指令结束<br>建议使用防卫式声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __HEAD_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HEAD_H__</span><br><br>...<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 迭代器基础</title>
    <link href="/2023/10/24/%E7%AC%AC%E4%B8%89%E7%AB%A0_%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/10/24/%E7%AC%AC%E4%B8%89%E7%AB%A0_%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h3><p>行为类似于指针，迭代器也提供了对对象进行间接访问<br>所有标准库容器都支持迭代器，string 不属于容器但也支持迭代器</p><ul><li>使用迭代器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> start = v.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//第一个元素的迭代器</span><br><span class="hljs-keyword">auto</span> end = v.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//尾后迭代器（尾元素的下一个位置）</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;通过迭代器修改元素，效果与引用或指针一样&#x3D;&#x3D;<br>迭代器也可以通过递增操作实现访问下一元素，最多移动到尾后迭代器<br>迭代器判断使用<code>!=</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        cout &lt;&lt; *it &lt;&lt; endl; <span class="hljs-comment">//类似指针解引用，箭头运算符也可以使用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>迭代器类型<ol><li>iterator<br>可读可写</li><li><code>const_iterator</code>（类似于指针常量）<br>可读不可写</li><li><code>cbegin</code> 和 <code>cend</code><br>返回 <code>const_iterator</code> 类型<br>&#x3D;&#x3D;使用了迭代器的循环体，就不能再向迭代器所属的容器中添加元素，否则会导致迭代器失效&#x3D;&#x3D;</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++ Primer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
